

This document explores potential exploitation paths for CVE-2026-20820, building on the vulnerability root cause analysis in `Writeup.md`.

## Vulnerability Recap

- **IOCTL**: `0x80076816` → `CClfsRequest::ScanContainers`
- **Buffer Method**: `METHOD_OUT_DIRECT` (user buffer mapped via MDL)
- **Bug**: Bounds check validates `ContainerCount * 0x240 <= OutputBufferLength` but fails to account for the 0x38-byte `CLS_SCAN_CONTEXT` header
- **Result**: Up to 0x38 bytes of `CLS_CONTAINER_INFORMATION` written past the user buffer boundary

### Overflow Content

The overflowed data (last 0x38 bytes of `CLS_CONTAINER_INFORMATION`):

| Offset | Field                   | Size | Attacker Control                                |
| ------ | ----------------------- | ---- | ----------------------------------------------- |
| 0x208  | `FileName[0x208:0x230]` | 0x28 | High (container name via `AddLogContainer`)     |
| 0x230  | `State`                 | 0x4  | Partial (runtime state flags)                   |
| 0x234  | `PhysicalContainerId`   | 0x4  | Low (bitmap slot index, assigned at creation)   |
| 0x238  | `LogicalContainerId`    | 0x4  | Low (assigned during container wrap operations) |

---

## Overflow Target: System PTE Region (Kernel Heap)

### The Key Insight

When `MmMapLockedPagesSpecifyCache` maps the MDL, it returns a **kernel virtual address** from the **System PTE Region**. The overflow writes past the MDL boundary into **adjacent kernel heap allocations**.

```c
// CClfsRequest::ScanContainers @ 0x140045fd1
MmMapLockedPagesSpecifyCache(
    MemoryDescriptorList,   // MDL describing user buffer
    0,                       // AccessMode = KernelMode (NOT UserMode!)
    MmCached,               // CacheType
    nullptr,                // RequestedAddress
    0,                      // BugCheckOnFailure = FALSE
    0x40000010              // Priority = HighPagePriority | MdlMappingNoExecute
);
```

**The second parameter `0` = `KernelMode`** means the MDL is mapped into **kernel virtual address space**, specifically the System PTE Region (`0xFFFFF880'00000000` range on x64).

### Memory Layout

```
                    PHYSICAL MEMORY
                    ┌─────────────────────┐
                    │  User Buffer Pages  │ ← Physical pages from user allocation
                    │  (N pages)          │
                    └─────────────────────┘
                              │
            ┌─────────────────┴─────────────────┐
            │                                   │
            ▼                                   ▼
    USER VIRTUAL SPACE                  KERNEL VIRTUAL SPACE
    ┌─────────────────────┐            ┌─────────────────────┐
    │ User Buffer         │            │ System PTE Mapping  │ ← 0xFFFFF880'xxxxxxxx
    │ (original alloc)    │            │ (same physical pages│
    └─────────────────────┘            │  mapped here too)   │
                                       ├─────────────────────┤
                                       │ OVERFLOW REGION     │ ← Adjacent kernel heap!
                                       │ (0x38 bytes)        │
                                       └─────────────────────┘
```

### What's Adjacent in System PTE Region?

The System PTE region is used for kernel heap-like allocations:

| Allocation Type | Exploitation Potential | Notes |
|-----------------|------------------------|-------|
| Other MDL Mappings | High | Cross-driver data/header corruption |
| Large Pool Objects (>4KB) | High | Pool object metadata/data corruption |
| Mapped Driver Sections | Medium | Driver data corruption |
| Mapped File Sections | Medium | Cache data corruption |
| I/O Adapter Mappings | Low | Device memory corruption |

**Key insight**: There are **NO guard pages** between System PTE allocations by default.

### Why MSRC's Classification Is Correct

MSRC classified this as a "heap-based buffer overflow" leading to EoP. This is accurate because:

1. The overflow corrupts **kernel virtual address space** (heap-like allocations in System PTE)
2. Adjacent allocations include other MDL buffers and large pool objects
3. Corrupting kernel object headers/data can lead to privilege escalation
4. This is a **kernel heap overflow**, not a user-mode overflow

---

## Data Flow Summary

```
User Mode                          Kernel Mode (System PTE Region)
─────────                          ────────────────────────────────
DeviceIoControl(                   
  IOCTL: 0x80076816,              
  OutputBuffer,          ────────► I/O Manager creates MDL
  OutputBufferLength)              MDL describes user physical pages
                                   │
                                   ▼
                                   MmMapLockedPagesSpecifyCache(
                                     MDL, 
                                     KernelMode,  ← KEY: Kernel VA!
                                     MmCached,
                                     NULL, FALSE, 0x40000010)
                                   │
                                   ▼
                                   Returns System VA: 0xFFFFF880'xxxxxxxx
                                   (System PTE Region - no guard pages!)
                                   │
                                   ▼
                                   CClfsRequest::ScanContainers()
                                   - Reads CLS_SCAN_CONTEXT from SystemVA
                                   - Bounds check: Count*0x240 <= OutLen
                                   - MISSING: + 0x38 for header
                                   │
                                   ▼
                                   CClfsBaseFile::ScanContainerInfo()
                                   - Writes CLS_CONTAINER_INFORMATION[]
                                   - Starting at SystemVA + 0x38
                                   - Last entry overflows by 0x38 bytes
                                   │
                                   ▼
                                   OVERFLOW TARGET (Kernel VA):
┌──────────────────────────────────┼──────────────────────────────────┐
│ System PTE Region                │                                  │
│ ┌────────────────────────┐       │                                  │
│ │ [Our MDL Mapping]      │◄──────┘                                  │
│ │  MappedVA + Size       │                                          │
│ ├────────────────────────┤                                          │
│ │ [OVERFLOW: 0x38 bytes] │──────► Adjacent Kernel Heap Allocation   │
│ │  - Filename[0x208:]    │        - Other MDL buffer header?        │
│ │  - State, IDs          │        - Large pool object?              │
│ └────────────────────────┘                                          │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Explored Exploitation Avenues

### Avenue 1: Confused Deputy / Re-read Pattern

**Status**: Ruled Out

**Analysis**: After writing container information, `CClfsRequest::ScanContainers` re-reads `cContainersReturned` from the user buffer to calculate `IoStatus.Information`:

```
0x140046118: mov eax, dword [rdi+0x20]      ; Re-read cContainersReturned
0x14004611b: lea rcx, [rax+rax*8]
0x14004611f: shl rcx, 0x6                    ; * 0x240
0x140046127: mov qword [rax+0x38], rcx       ; IoStatus.Information
```

**Why it doesn't work**: The overflow writes **forward** past the end of the buffer, not backward to the `CLS_SCAN_CONTEXT` header at offset 0. The `cContainersReturned` field (offset 0x20) cannot be corrupted by this overflow.

---

### Avenue 2: TOCTOU / Race Condition

**Status**: Ruled Out

**Analysis**: The MDL-locked buffer remains accessible to user mode while the kernel operates on it. Examined for race conditions:

**Fields read from user buffer**:
- `cContainers` (offset 0x18) - captured to local variable early
- `eScanMode` (offset 0x28) - captured to local variable early  
- `cIndex` (offset 0x10) - captured to local variable early
- `pinfoContainer` (offset 0x30) - checked for NULL only

**Why it doesn't work**: 
- Critical values are captured into local variables before the scan operation
- The `pinfoContainer` field is only null-checked; the actual write destination is computed as `MappedSystemVA + 0x38`, ignoring the pointer value
- No exploitable TOCTOU window identified

---

### Avenue 3: Kernel-Mode Caller Path

**Status**: Ruled Out

**Analysis**: CLFS exports `ClfsScanLogContainers` for kernel-mode callers. Examined whether this shares the vulnerability.

**Finding**: The kernel-mode API (`ClfsScanLogContainersInternal`) calls the FCB's `ScanContainers` method but:
1. The vulnerable bounds check is in `CClfsRequest::ScanContainers` (IOCTL handler only)
2. Kernel callers provide their own buffer with appropriate sizing
3. No shared vulnerability path identified

---

### Avenue 4: Container ID Controllability

**Status**: Limited Control

**Analysis**: Examined how `PhysicalContainerId` and `LogicalContainerId` are assigned to determine attacker control over overflow data.

**Findings**:
- `PhysicalContainerId`: Assigned based on first free slot in container bitmap - not directly controllable
- `LogicalContainerId`: Assigned during runtime container wrap operations - not directly controllable
- Only the `FileName` portion (0x28 bytes) is truly attacker-controlled

---

### Avenue 5: Shared Memory / Section Exploitation

**Status**: Ruled Out

**Analysis**: Investigated whether mapping the output buffer from a shared section could enable kernel exploitation.

**Conclusion**: The physical page isolation between user buffers and kernel structures prevents shared memory exploitation. The MDL maps user pages that have no automatic kernel-side sharing.

---

## Primary Exploitation Path: Kernel Heap Object Corruption

### Target: Adjacent Large Pool / MDL Objects

The overflow corrupts whatever kernel heap object is allocated immediately after our MDL mapping in the System PTE region. Potential targets include:

1. **Other Driver MDL Buffers**: If another driver has an MDL-mapped buffer adjacent to ours, we can corrupt its header or data
2. **Large Pool Objects**: Objects >4KB are backed by System PTEs directly
3. **Mapped Sections**: Driver or cache manager mapped sections

### Heap Feng Shui Strategy

```
PHASE 1: Deplete/Groom System PTEs
──────────────────────────────────
- Trigger allocations to consume free System PTEs
- Goal: Force sequential allocation behavior

PHASE 2: Spray Target Objects
────────────────────────────
- Allocate many instances of exploitable kernel objects
- Objects should be allocated via large pool or MDL mappings
- Goal: High probability of adjacent placement

PHASE 3: Create Holes
────────────────────
- Free specific allocations to create "holes"
- Goal: Our MDL will land in a hole adjacent to target object

PHASE 4: Trigger Vulnerable IOCTL
────────────────────────────────
- DeviceIoControl for ScanContainers
- Our MDL maps into a hole
- Overflow corrupts adjacent target object

PHASE 5: Trigger Use of Corrupted Object
───────────────────────────────────────
- Cause kernel to use the corrupted object
- Corrupted size/pointer/callback leads to exploitation primitive
```

### Promising Kernel Object Targets

Objects that could be useful if corrupted by 0x38 bytes:

| Object Type | Corruption Target | Exploitation Primitive |
|-------------|-------------------|----------------------|
| Pool object with size field | Size at offset 0-8 | Out-of-bounds R/W |
| Object with function pointer | Callback at offset 0-0x28 | Code execution (needs KASLR bypass) |
| Object with data pointer | Pointer at offset 0-0x28 | Arbitrary R/W |
| Quota/reference count | Count field | Use-after-free setup |

### Overflow Content for Exploitation

```
Bytes 0x00-0x27: Container Filename (WCHAR[20])
                 ├─ FULLY CONTROLLED via AddLogContainer
                 ├─ Can encode arbitrary values (with WCHAR constraints)
                 └─ Restricted chars: / \ : * ? " < > | NUL

Bytes 0x28-0x2B: State (CLFS_CONTAINER_STATE)
                 └─ Partial control via container operations

Bytes 0x2C-0x2F: PhysicalContainerId
                 └─ Bitmap index, not directly controllable

Bytes 0x30-0x37: LogicalContainerId + padding
                 └─ Wrap counter, not directly controllable
```

**Key constraint**: The first 0x28 bytes are the most useful as they're fully attacker-controlled (subject to filename character restrictions).

---

## Exploitation Feasibility Assessment

| Path | Feasibility | Notes |
|------|-------------|-------|
| **Kernel heap object corruption** | **Medium-High** | Primary path - requires identifying good target object |
| Confused deputy | None | Overflow direction wrong |
| TOCTOU race | None | Values captured to locals early |
| Shared section abuse | None | Physical page isolation |
| Container ID manipulation | Low | IDs assigned by kernel |

---

## Attack Complexity Assessment

| Factor | Assessment |
|--------|------------|
| Vulnerability trigger | Easy - simple IOCTL with crafted parameters |
| Container name control | Full - set via `AddLogContainer` |
| System PTE positioning | Medium-Hard - heap feng shui required |
| Target object identification | Medium - need to find suitable object |
| KASLR bypass (if needed) | Hard - requires separate info leak |
| Kernel EoP | **Achievable** with right target object |

---

## Mitigations Analysis

| Mitigation | Impact on Exploit |
|------------|-------------------|
| KASLR | Only matters if corrupting function pointers |
| HVCI | Doesn't prevent data corruption |
| SMEP/SMAP | Not relevant (exploit stays in kernel mode) |
| Pool hardening | May affect target object selection |

---

## Recommendations for Further Research

1. **Identify Target Objects**: Research which kernel objects allocated via large pool or MDL mappings have exploitable fields in their first 0x38 bytes (size fields, pointers, callbacks).

2. **System PTE Allocation Patterns**: Study how Windows allocates from System PTE region to develop reliable heap feng shui techniques.

3. **Cross-Driver Attacks**: Investigate if specific drivers have MDL buffers with exploitable headers that could be targeted.

4. **KASLR Bypass**: If targeting function pointers, identify information disclosure techniques to defeat KASLR.

5. **Filename Character Testing**: Empirically test which WCHAR values are accepted by `AddLogContainer` to determine exact payload constraints.

---

## Appendix: Overflow Data Controllability Summary

| Field | Offset in Overflow | Size | Control Level | Notes |
|-------|-------------------|------|---------------|-------|
| FileName tail | 0x00 | 0x28 | **High** | Unicode, set via `AddLogContainer` |
| State | 0x28 | 0x04 | Low | Runtime flags (0x02, 0x04, 0x10, etc.) |
| PhysicalContainerId | 0x2C | 0x04 | None | `RtlFindClearBits` bitmap index |
| LogicalContainerId | 0x30 | 0x04 | None | Assigned during wrap operations |

**Effective attacker-controlled payload**: 0x28 bytes of Unicode string data, constrained by valid filename characters.
