<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CVE-2024-11616: Netskope EPDLP Double-Fetch | Inbits Blog</title><meta name=keywords content><meta name=description content="Around a year ago, I decided to orient myself more keenly towards vulnerability research. It had become apparent to me that it was the area of offensive security, and the process, that I had enjoyed dipping my toes into the most. I spent much of the last year shoring up fundamentals - finishing Ret2Systems&rsquo; excellent Wargames, a bunch of OST2 modules, and the Trainsec Kernel Programming modules - before jumping into some real world targets and starting to develop my workflow. This blog post documents the first vulnerability that I found and reported, CVE-2024-11616, in a driver created by Netskope. The bug is a pretty typical double-fetch, and requires elevated privileges to exploit, but due to the risk of Bring Your Own Vulnerable Driver (BYOVD) attacks, these bugs are still pretty important for vendors to catch. Despite it being a simple bug, successfully reporting something was a milestone I was eager to hit, so a small writeup seemed justified!"><meta name=author content="Tom Brice"><link rel=canonical href=http://localhost:1313/posts/cve-2024-11616-netskope/><link crossorigin=anonymous href=/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/cve-2024-11616-netskope/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://localhost:1313/posts/cve-2024-11616-netskope/"><meta property="og:site_name" content="Inbits Blog"><meta property="og:title" content="CVE-2024-11616: Netskope EPDLP Double-Fetch"><meta property="og:description" content="Around a year ago, I decided to orient myself more keenly towards vulnerability research. It had become apparent to me that it was the area of offensive security, and the process, that I had enjoyed dipping my toes into the most. I spent much of the last year shoring up fundamentals - finishing Ret2Systems’ excellent Wargames, a bunch of OST2 modules, and the Trainsec Kernel Programming modules - before jumping into some real world targets and starting to develop my workflow. This blog post documents the first vulnerability that I found and reported, CVE-2024-11616, in a driver created by Netskope. The bug is a pretty typical double-fetch, and requires elevated privileges to exploit, but due to the risk of Bring Your Own Vulnerable Driver (BYOVD) attacks, these bugs are still pretty important for vendors to catch. Despite it being a simple bug, successfully reporting something was a milestone I was eager to hit, so a small writeup seemed justified!"><meta property="og:locale" content="en-gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-28T12:32:40+00:00"><meta property="article:modified_time" content="2024-12-28T12:32:40+00:00"><meta property="og:image" content="http://localhost:1313/%3Castro.jpg%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Castro.jpg%3E"><meta name=twitter:title content="CVE-2024-11616: Netskope EPDLP Double-Fetch"><meta name=twitter:description content="Around a year ago, I decided to orient myself more keenly towards vulnerability research. It had become apparent to me that it was the area of offensive security, and the process, that I had enjoyed dipping my toes into the most. I spent much of the last year shoring up fundamentals - finishing Ret2Systems&rsquo; excellent Wargames, a bunch of OST2 modules, and the Trainsec Kernel Programming modules - before jumping into some real world targets and starting to develop my workflow. This blog post documents the first vulnerability that I found and reported, CVE-2024-11616, in a driver created by Netskope. The bug is a pretty typical double-fetch, and requires elevated privileges to exploit, but due to the risk of Bring Your Own Vulnerable Driver (BYOVD) attacks, these bugs are still pretty important for vendors to catch. Despite it being a simple bug, successfully reporting something was a milestone I was eager to hit, so a small writeup seemed justified!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"CVE-2024-11616: Netskope EPDLP Double-Fetch","item":"http://localhost:1313/posts/cve-2024-11616-netskope/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CVE-2024-11616: Netskope EPDLP Double-Fetch","name":"CVE-2024-11616: Netskope EPDLP Double-Fetch","description":"Around a year ago, I decided to orient myself more keenly towards vulnerability research. It had become apparent to me that it was the area of offensive security, and the process, that I had enjoyed dipping my toes into the most. I spent much of the last year shoring up fundamentals - finishing Ret2Systems\u0026rsquo; excellent Wargames, a bunch of OST2 modules, and the Trainsec Kernel Programming modules - before jumping into some real world targets and starting to develop my workflow. This blog post documents the first vulnerability that I found and reported, CVE-2024-11616, in a driver created by Netskope. The bug is a pretty typical double-fetch, and requires elevated privileges to exploit, but due to the risk of Bring Your Own Vulnerable Driver (BYOVD) attacks, these bugs are still pretty important for vendors to catch. Despite it being a simple bug, successfully reporting something was a milestone I was eager to hit, so a small writeup seemed justified!\n","keywords":[],"articleBody":"Around a year ago, I decided to orient myself more keenly towards vulnerability research. It had become apparent to me that it was the area of offensive security, and the process, that I had enjoyed dipping my toes into the most. I spent much of the last year shoring up fundamentals - finishing Ret2Systems’ excellent Wargames, a bunch of OST2 modules, and the Trainsec Kernel Programming modules - before jumping into some real world targets and starting to develop my workflow. This blog post documents the first vulnerability that I found and reported, CVE-2024-11616, in a driver created by Netskope. The bug is a pretty typical double-fetch, and requires elevated privileges to exploit, but due to the risk of Bring Your Own Vulnerable Driver (BYOVD) attacks, these bugs are still pretty important for vendors to catch. Despite it being a simple bug, successfully reporting something was a milestone I was eager to hit, so a small writeup seemed justified!\nTarget For those unfamiliar, Netskope is a leading provider in the Cloud Security and Data Protection space. Like most security companies now, they offer a platform consisting of a multitude of different products and tools. Chief among these are their Data Loss Prevention (DLP), and Secure Service Edge (SSE) products. According to themselves, they are used by at least one third of the Fortune 100.\nThe vulnerability I’ll be covering was found in the “Endpoint DLP” (EPDLP) feature, an optional add-on in the Netskope client. EPDLP aims to provide visibility and control over files moving between a host and storage device - specifically a USB storage device, printer, network file share, or device connecting over Bluetooth. EPDLP has two constituent parts - Device Control and Content Control. Device control policies determine whether or not a device should be allowed, blocked, or read-only. Content Control policies house more of the actual DLP functionality, allowing you to permit or block files from being transferred based on various criteria. You may decide to only permit writing certain file types to the drive, or only transferring files downloaded from specific applications.\nOn Windows, these two different parts of EPDLP are implemented in separate drivers - Device Control in epdlp_dev_ctrl.sys and Content Control in epdlpdrv.sys. The bug was found in the Content Control driver, which unsurprisingly has a much larger attack surface than its Device Control counterpart.\nepdlpdrv.sys is a particular type of Windows driver known as a file system minifilter. These drivers allow you to read, intercept, and modify, any I/O request making its way to the actual file system driver. Minifilter drivers don’t sit directly in the driver stack, but are instead registered with the Filter Manager (FltMgr), which Microsoft introduced to simplify the process of creating file system filter drivers. For a proper overview, I would insist on reading the inimitable James Forshaw’s article on researching filesystem mini-filters, a post that I returned to dozens of times whilst reverse engineering the driver.\nFilter Communication Port Background If you are familiar with Windows drivers, you can probably skip this bit. And I’ll try to re-tread over only the parts of James Forshaw’s post that are most relevant to the bug.\nThe Filter Manager introduces a unique method of communication that minifilter drivers can use - Filter Communication Ports. These communication ports are provided by the filter manager to support bidirectional communication between a user-mode app, and a kernel-mode minifilter.\nParaphrasing from the docs, communication is established like so:\nThe minifilter driver calls FltCreateCommunicationPort, to create the listening server port. Included in its parameters are a security descriptor that is applied to the communication port object, as well as three callback functions, ConnectNotifyCallback, MessageNotifyCallback, and DeleteNotifyCallback. Once the port is created, the minifilter begins listening for incoming connections. A user-mode app calls FilterConnectCommunicationPort to attempt to connect to the port. The Filter Manager calls the ConnectNotifyCallback, passing it a handle to the newly created connection. When the callback completes, the Filter Manager passes the user-mode caller a separate file handle that represents the user-mode endpoint to the connection. The user-mode application can then call FilterSendMessage to deliver raw buffers to the MessageNotifyCallback that was supplied when the port was created. The typical way to communicate with a driver from userland (at least with any flexibility) is to use DeviceIoControl, which without too much of a tangent, involves passing a 4-byte value known as an I/O Control Code (IOCTL). This value is passed in the I/O Request Packet (IRP) to a callback function that the driver registers when it is loaded. This callback will usually then have a switch statement on the IOCTL that calls different functions depending on what the IOCTL contains.\nWhy use a communication port over the typical non-minifilter driver method of communication, DeviceIoControl? According to Microsoft, it’s faster and more efficient because it isn’t buffered, has more granular security controls due to security descriptors being attached to the port objects (rather than access being tied to the device object), and provides message queueing. James Forshaw sheds some light on why this might be: \"…under the hood it’s implemented using the device IO control code 0x8801B. As this code uses the METHOD_NEITHER method means the InputBuffer and OutputBuffer parameters are pointers into user-mode memory. The filter manager does check them before calling the callback with ProbeForRead and ProbeForWrite calls.\"\nThis is very relevant for the bug we are going to look at. One of the bits of data used to construct the IOCTL is a Method value that indicates to the I/O Manager how we want to handle the input and output buffers passed in the DeviceIoControl call. The options are as follows:\nMETHOD_BUFFERED - Causes the I/O Manager to create a buffer in kernelspace that the input buffer is copied to. The driver works with this buffer instead of touching the original buffer in userspace, and then the driver writes output to the same kernel buffer, which the I/O Manager then copies back to the output buffer passed in the DeviceIoControl call. From what I’ve seen, this is the most common case. Documented here METHOD_IN_DIRECT and METHOD_OUT_DIRECT - For both of these options, the input buffer is copied to a kernelspace buffer, as with METHOD_BUFFERED. For the second buffer supplied, the output buffer, the I/O Manager locks the physical memory so it can’t be paged out, and prepares a Memory Descriptor List (MDL) pointing to that userspace memory. If METHOD_IN_DIRECT has been used, the I/O Manager will probe to ensure the executing thread only has read-access to the buffer (as it is intended to be used as another input buffer). If METHOD_OUT_DIRECT is used, the I/O Manager will probe to ensure the buffer is writable. Documented here METHOD_NEITHER - The sketchiest option, whereby the I/O Manager just… does nothing. With this method, the driver is responsible for validating the pointers supplied for the input/output buffer. It’s the fastest because the buffers aren’t copied or mapped anywhere, but the most error-prone. Documented here The filter manager mitigates some of the risk of using METHOD_NEITHER by probing the addresses passed in the buffer arguments, checking they aren’t in kernelspace and that they are correctly aligned. However, because the input buffer isn’t copied to kernel memory, the risk still remains for standard double-fetch bugs. A double-fetch is a type of “Time-Of-Check to Time-Of-Use” bug, usually shortened to TOCTOUs, which are more generally caused by race conditions. The name is sort of self-explanatory - a program checks a value, usually validating that it falls within acceptable limits, and then later in the program the value is used again, assuming it is still within acceptable limits. The race is whether the value can be changed in-between being validated, and being used for something.\nWhen it comes to double-fetch bugs in drivers or the kernel, there is a common pattern:\nAn input buffer is supplied that exists in user memory An address in that input buffer is dereferenced and some validation is performed Later in the program, that same address in the input buffer is dereferenced again and used as a value in a function call (usually as a length or count of some other data) This issue here is that the value is dereferenced from user memory on both occasions, and can theoretically be changed by the user that allocated the memory. The fix is simple - the driver needs to copy the value to a local variable, and perform both the validation and the actual use of the value using the variable rather than fetching it directly from the input buffer both times. For more information on double-fetches, there is an incredible whitepaper by Mateusz ‘j00ru’ Jurczyk and Gynvael Coldwind, where they find numerous double-fetches at-scale across Windows using the Bochs emulator to analyse memory access patterns. They also cover exploitation and how the odds of winning the race condition can be made more favourable.\nAs you’ve probably guessed, this pattern is what I found in the EPDLP driver - a double-fetch of user memory provided in the input buffer sent to a filter communication port call.\nThe Vulnerability During initialisation in the DriverEntry function, two filter communication ports are created, EpdlpPort and EpdlpPort1. The first one, EpdlpPort, has a security descriptor returned from FltBuildDefaultSecurityDescriptor, resulting in the port only being accessible to users with system or administrator privileges (the second port, EpdlpPort1, uses the same security descriptor, but only after a call to RtlSetDaclSecurityDescriptor, where the DACL on the security descriptor is nulled out - effectively giving all users unconditional access to the port object).\nThe first communication port is restricted to privileged users because it is the interface exposing the administrative functionality for the Endpoint DLP service. It is called by the EPDLP userland service, epdlp.exe.\nif (FltBuildDefaultSecurityDescriptor(\u0026SecurityDescriptor, DesiredAccess: 0x1f0001) s\u003c STATUS_SUCCESS) goto label_140021630 OBJECT_ATTRIBUTES ObjectAttributes ObjectAttributes.ObjectName = \u0026commPortName ObjectAttributes.SecurityDescriptor = SecurityDescriptor ObjectAttributes.Length = 0x30 ObjectAttributes.RootDirectory = 0 ObjectAttributes.Attributes = 0x240 ObjectAttributes.SecurityQualityOfService = 0 FltCreateCommunicationPort(Filter: fltFilter, ServerPort: \u0026serverPort1, \u0026ObjectAttributes, ServerPortCookie: nullptr, ConnectNotifyCallback: CreateEpdlpHandle, DisconnectNotifyCallback: disconnectNotifyCallback1, MessageNotifyCallback: messageNotifyCallbackFunc, MaxConnections: 1) The MessageNotifyCallback registered to the EpdlpPort communication port simply calls another function - which here I’ve just named messageNotify - passing only the PortCookie, InputBuffer, and InputBufferLen arguments from the callback.\nAt 1, we can see, the messageNotify function dereferences the first 4-bytes of the InputBuffer and uses this value in a switch statement to determine which administrative function should be performed. Most of the options here relate to EPDLP functionality that isn’t enabled by default - the driver actually contains capability to inject a DLL into userland processes via a Kernel APC, and there are administrative options here to manually trigger that process, or to update a list of excluded processes that shouldn’t be hooked.\nIn this case we care about the first option, as EpdlpSetUsbAction is where we find our double-fetch. At 2 we can see some initial validation checks on the arguments supplied, namely that the InputBuffer isn’t NULL, and that its length isn’t less than 4 bytes. Then at 3 in the case 1 block, there is also a comparison made between the InputBufferLen and a dereferenced value at InputBuffer+4, indicating that we likely have other length fields supplied by the user. The InputBuffer is then passed to EpdlpSetUsbAction as the only argument at 4.\nThe EPDLP driver maintains a global array of objects that describe mounted volumes on the system. The EpdlpSetUsbAction function, as the name suggests, allows the caller to update a value on a specific one of these objects, determining whether the USB is accessible. The caller supplies the ID (field name DeviceInstanceId) of the target volume as a wide char string in InputBuffer+0x10, along with a corresponding string length at InputBuffer+0xc. The function later loops through the global array of objects and compares the supplied ID in order to find the right one. The DeviceInstanceId contained in the object, however, is a UNICODE_STRING, so the EpdlpSetUsbAction function copies the supplied string into an allocated buffer and constructs the UNICODE_STRING object - and this is where the bug lies.\nAs viewable in the function above at 1, the supplied string length at InputBuffer+0xc is used as the NumberOfBytes argument in the ExAllocatePoolWithTag function. The returned pointer is assigned as the Buffer value in the new UNICODE_STRING. Then, RtlCopyMemory is called in order to copy the caller supplied string into the heap memory, and the Length argument is a second dereference of InputBuffer+0xc, noted as 2.\nThis is the double-fetch, and by causing the ExAllocatePoolWithTag call to execute with a NumberOfBytes value that then grows into a larger value by the subsequent RtlCopyMemory call, we can overflow the heap memory with user-supplied data.\nPoC Exploiting a double-fetch for a PoC typically involves a few steps:\nAllocate some memory to use as our input buffer Create a “flipping” thread that runs a while loop that continually XORs the value of a global variable. This global variable will be the value in the buffer that is double-fetched by the driver. (For the purpose of a crash, we can simply XOR the value to make it alternate between a small number and a bigger one.) In our main thread, run a function with another while loop that continually calls FilterSendMessage with our input buffer. In this particular case, there is one other thing we need to do that I haven’t mentioned yet. Astute readers may have noticed earlier that the first FltCreateCommunicationPort call passes a MaxConnections argument with its value set to 1. This connection will already be in use by the EPDLP userland service. For us to be able to connect to the port and reach the double-fetch, we need to kill the service to free the connection. Seeing as we need elevated privileges to connect to the communication port, this isn’t much of a hurdle. If we didn’t need elevated privileges to call the communication port, it would have been worthwhile looking for a way to DoS/restart the EPDLP service as an unprivileged user in order to create a window where the communication port connection is available.\nPoC code is here: https://github.com/inb1ts/CVE-2024-11616\nAlso shoutout to the Netskope PSIRT team who were always responsive and easy to work with throughout the reporting process!\nReferences https://www.netskope.com/company/security-compliance-and-assurance/security-advisories-and-disclosures/netskope-security-advisory-nskpsa-2024-003 https://www.cve.org/CVERecord?id=CVE-2024-11616 https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html https://j00ru.vexillium.org/papers/2013/bochspwn.pdf https://exploits.forsale/24h2-nt-exploit/ https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/communication-between-user-mode-and-kernel-mode ","wordCount":"2369","inLanguage":"en","image":"http://localhost:1313/%3Castro.jpg%3E","datePublished":"2024-12-28T12:32:40Z","dateModified":"2024-12-28T12:32:40Z","author":{"@type":"Person","name":"Tom Brice"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/cve-2024-11616-netskope/"},"publisher":{"@type":"Organization","name":"Inbits Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Inbits Blog (Alt + H)">Inbits Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title="about me"><span>about me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CVE-2024-11616: Netskope EPDLP Double-Fetch</h1><div class=post-meta><span title='2024-12-28 12:32:40 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;<span>12 min</span>&nbsp;·&nbsp;<span>Tom Brice</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#target aria-label=Target>Target</a></li><li><a href=#filter-communication-port-background aria-label="Filter Communication Port Background">Filter Communication Port Background</a></li><li><a href=#the-vulnerability aria-label="The Vulnerability">The Vulnerability</a></li><li><a href=#poc aria-label=PoC>PoC</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>Around a year ago, I decided to orient myself more keenly towards vulnerability research. It had become apparent to me that it was the area of offensive security, and the process, that I had enjoyed dipping my toes into the most. I spent much of the last year shoring up fundamentals - finishing Ret2Systems&rsquo; excellent <a href=https://wargames.ret2.systems/>Wargames</a>, a bunch of <a href=https://p.ost2.fyi/>OST2 modules</a>, and the Trainsec <a href=https://training.trainsec.net/windows-kernel-programming-1>Kernel Programming modules</a> - before jumping into some real world targets and starting to develop my workflow. This blog post documents the first vulnerability that I found and reported, <a href="https://www.cve.org/CVERecord?id=CVE-2024-11616">CVE-2024-11616</a>, in a driver created by <a href=https://www.netskope.com/>Netskope</a>. The bug is a pretty typical double-fetch, and requires elevated privileges to exploit, but due to the risk of Bring Your Own Vulnerable Driver (BYOVD) attacks, these bugs are still pretty important for vendors to catch. Despite it being a simple bug, successfully reporting something was a milestone I was eager to hit, so a small writeup seemed justified!</p><h2 id=target>Target<a hidden class=anchor aria-hidden=true href=#target>#</a></h2><p>For those unfamiliar, Netskope is a leading provider in the Cloud Security and Data Protection space. Like most security companies now, they offer a platform consisting of a multitude of different products and tools. Chief among these are their Data Loss Prevention (DLP), and Secure Service Edge (SSE) products. According to themselves, they are used by at least one third of the Fortune 100.</p><p>The vulnerability I&rsquo;ll be covering was found in the &ldquo;Endpoint DLP&rdquo; (EPDLP) feature, an optional add-on in the Netskope client. EPDLP aims to provide visibility and control over files moving between a host and storage device - specifically a USB storage device, printer, network file share, or device connecting over Bluetooth. EPDLP has two constituent parts - Device Control and Content Control. Device control policies determine whether or not a device should be allowed, blocked, or read-only. Content Control policies house more of the actual DLP functionality, allowing you to permit or block files from being transferred based on various criteria. You may decide to only permit writing certain file types to the drive, or only transferring files downloaded from specific applications.</p><p>On Windows, these two different parts of EPDLP are implemented in separate drivers - Device Control in <code>epdlp_dev_ctrl.sys</code> and Content Control in <code>epdlpdrv.sys</code>. The bug was found in the Content Control driver, which unsurprisingly has a much larger attack surface than its Device Control counterpart.</p><p><code>epdlpdrv.sys</code> is a particular type of Windows driver known as a file system minifilter. These drivers allow you to read, intercept, and modify, any I/O request making its way to the actual file system driver. Minifilter drivers don&rsquo;t sit directly in the driver stack, but are instead registered with the Filter Manager (FltMgr), which Microsoft introduced to simplify the process of creating file system filter drivers. For a proper overview, I would insist on reading the inimitable James Forshaw&rsquo;s <a href=https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html>article on researching filesystem mini-filters</a>, a post that I returned to dozens of times whilst reverse engineering the driver.</p><h2 id=filter-communication-port-background>Filter Communication Port Background<a hidden class=anchor aria-hidden=true href=#filter-communication-port-background>#</a></h2><p><em>If you are familiar with Windows drivers, you can probably skip this bit. And I&rsquo;ll try to re-tread over only the parts of James Forshaw&rsquo;s post that are most relevant to the bug.</em></p><p>The Filter Manager introduces a unique method of communication that minifilter drivers can use - Filter Communication Ports. These communication ports are provided by the filter manager to support bidirectional communication between a user-mode app, and a kernel-mode minifilter.</p><p>Paraphrasing from <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/communication-between-user-mode-and-kernel-mode>the docs</a>, communication is established like so:</p><ul><li>The minifilter driver calls <code>FltCreateCommunicationPort</code>, to create the listening server port. Included in its parameters are a security descriptor that is applied to the communication port object, as well as three callback functions, <code>ConnectNotifyCallback</code>, <code>MessageNotifyCallback</code>, and <code>DeleteNotifyCallback</code>. Once the port is created, the minifilter begins listening for incoming connections.</li><li>A user-mode app calls <code>FilterConnectCommunicationPort</code> to attempt to connect to the port. The Filter Manager calls the <code>ConnectNotifyCallback</code>, passing it a handle to the newly created connection. When the callback completes, the Filter Manager passes the user-mode caller a separate file handle that represents the user-mode endpoint to the connection.</li><li>The user-mode application can then call <code>FilterSendMessage</code> to deliver raw buffers to the <code>MessageNotifyCallback</code> that was supplied when the port was created.</li></ul><p>The typical way to communicate with a driver from userland (at least with any flexibility) is to use <code>DeviceIoControl</code>, which without too much of a tangent, involves passing a 4-byte value known as an I/O Control Code (IOCTL). This value is passed in the I/O Request Packet (IRP) to a callback function that the driver registers when it is loaded. This callback will usually then have a switch statement on the IOCTL that calls different functions depending on what the IOCTL contains.</p><p>Why use a communication port over the typical non-minifilter driver method of communication, <code>DeviceIoControl</code>? According to Microsoft, it&rsquo;s faster and more efficient because it isn&rsquo;t buffered, has more granular security controls due to security descriptors being attached to the port objects (rather than access being tied to the device object), and provides message queueing. James Forshaw sheds some light on why this might be: <em>"&mldr;under the hood it’s implemented using the device IO control code 0x8801B. As this code uses the METHOD_NEITHER method means the InputBuffer and OutputBuffer parameters are pointers into user-mode memory. The filter manager does check them before calling the callback with <code>ProbeForRead</code> and <code>ProbeForWrite</code> calls."</em></p><p>This is very relevant for the bug we are going to look at. One of the bits of data used to construct the IOCTL is a <code>Method</code> value that indicates to the I/O Manager how we want to handle the input and output buffers passed in the <code>DeviceIoControl</code> call. The options are as follows:</p><ul><li><code>METHOD_BUFFERED</code> - Causes the I/O Manager to create a buffer in kernelspace that the input buffer is copied to. The driver works with this buffer instead of touching the original buffer in userspace, and then the driver writes output to the <em>same</em> kernel buffer, which the I/O Manager then copies back to the output buffer passed in the <code>DeviceIoControl</code> call. From what I&rsquo;ve seen, this is the most common case. <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes#method_buffered>Documented here</a></li><li><code>METHOD_IN_DIRECT</code> and <code>METHOD_OUT_DIRECT</code> - For both of these options, the input buffer is copied to a kernelspace buffer, as with <code>METHOD_BUFFERED</code>. For the second buffer supplied, the output buffer, the I/O Manager locks the physical memory so it can&rsquo;t be paged out, and prepares a <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls>Memory Descriptor List</a> (MDL) pointing to that userspace memory. If <code>METHOD_IN_DIRECT</code> has been used, the I/O Manager will probe to ensure the executing thread only has read-access to the buffer (as it is intended to be used as another <em>input</em> buffer). If <code>METHOD_OUT_DIRECT</code> is used, the I/O Manager will probe to ensure the buffer is writable. <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes#method_buffered>Documented here</a></li><li><code>METHOD_NEITHER</code> - The sketchiest option, whereby the I/O Manager just&mldr; does nothing. With this method, the driver is responsible for validating the pointers supplied for the input/output buffer. It&rsquo;s the fastest because the buffers aren&rsquo;t copied or mapped anywhere, but the most error-prone. <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes#method_buffered>Documented here</a></li></ul><p>The filter manager mitigates some of the risk of using <code>METHOD_NEITHER</code> by <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforread#remarks>probing the addresses</a> passed in the buffer arguments, checking they aren&rsquo;t in kernelspace and that they are correctly aligned. However, because the input buffer isn&rsquo;t copied to kernel memory, the risk still remains for standard double-fetch bugs. A double-fetch is a type of &ldquo;Time-Of-Check to Time-Of-Use&rdquo; bug, usually shortened to TOCTOUs, which are more generally caused by race conditions. The name is sort of self-explanatory - a program checks a value, usually validating that it falls within acceptable limits, and then later in the program the value is used again, assuming it is still within acceptable limits. The race is whether the value can be changed in-between being validated, and being used for something.</p><p>When it comes to double-fetch bugs in drivers or the kernel, there is a common pattern:</p><ul><li>An input buffer is supplied that exists in user memory</li><li>An address in that input buffer is dereferenced and some validation is performed</li><li>Later in the program, that same address in the input buffer is <em>dereferenced again</em> and used as a value in a function call (usually as a length or count of some other data)</li></ul><p>This issue here is that the value is dereferenced from user memory on both occasions, and can theoretically be changed by the user that allocated the memory. The fix is simple - the driver needs to copy the value to a local variable, and perform both the validation and the actual use of the value using the variable rather than fetching it directly from the input buffer both times. For more information on double-fetches, there is an <a href=https://j00ru.vexillium.org/papers/2013/bochspwn.pdf>incredible whitepaper</a> by Mateusz &lsquo;j00ru&rsquo; Jurczyk and Gynvael Coldwind, where they find numerous double-fetches at-scale across Windows using the Bochs emulator to analyse memory access patterns. They also cover exploitation and how the odds of winning the race condition can be made more favourable.</p><p>As you&rsquo;ve probably guessed, this pattern is what I found in the EPDLP driver - a double-fetch of user memory provided in the input buffer sent to a filter communication port call.</p><h2 id=the-vulnerability>The Vulnerability<a hidden class=anchor aria-hidden=true href=#the-vulnerability>#</a></h2><p>During initialisation in the <code>DriverEntry</code> function, two filter communication ports are created, <code>EpdlpPort</code> and <code>EpdlpPort1</code>. The first one, <code>EpdlpPort</code>, has a security descriptor returned from <code>FltBuildDefaultSecurityDescriptor</code>, resulting in the port only being accessible to users with system or administrator privileges (the second port, <code>EpdlpPort1</code>, uses the same security descriptor, but only after a call to <code>RtlSetDaclSecurityDescriptor</code>, where the DACL on the security descriptor is nulled out - effectively giving all users unconditional access to the port object).</p><p>The first communication port is restricted to privileged users because it is the interface exposing the administrative functionality for the Endpoint DLP service. It is called by the EPDLP userland service, <code>epdlp.exe</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FltBuildDefaultSecurityDescriptor</span>(<span style=color:#f92672>&amp;</span>SecurityDescriptor, DesiredAccess: <span style=color:#ae81ff>0x1f0001</span>) s<span style=color:#f92672>&lt;</span> STATUS_SUCCESS)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>goto</span> label_140021630
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>OBJECT_ATTRIBUTES ObjectAttributes
</span></span><span style=display:flex><span>ObjectAttributes.ObjectName <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>commPortName
</span></span><span style=display:flex><span>ObjectAttributes.SecurityDescriptor <span style=color:#f92672>=</span> SecurityDescriptor
</span></span><span style=display:flex><span>ObjectAttributes.Length <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x30</span>
</span></span><span style=display:flex><span>ObjectAttributes.RootDirectory <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>ObjectAttributes.Attributes <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x240</span>
</span></span><span style=display:flex><span>ObjectAttributes.SecurityQualityOfService <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>FltCreateCommunicationPort</span>(Filter: fltFilter, ServerPort: <span style=color:#f92672>&amp;</span>serverPort1, <span style=color:#f92672>&amp;</span>ObjectAttributes, ServerPortCookie: nullptr, ConnectNotifyCallback: CreateEpdlpHandle, DisconnectNotifyCallback: disconnectNotifyCallback1, MessageNotifyCallback: messageNotifyCallbackFunc, MaxConnections: <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>The <code>MessageNotifyCallback</code> registered to the <code>EpdlpPort</code> communication port simply calls another function - which here I&rsquo;ve just named <code>messageNotify</code> - passing only the <code>PortCookie</code>, <code>InputBuffer</code>, and <code>InputBufferLen</code> arguments from the callback.</p><p><img alt="Disassembly of messageNotify function" loading=lazy src=/messageNotify.png#center></p><p>At <code>1</code>, we can see, the <code>messageNotify</code> function dereferences the first 4-bytes of the <code>InputBuffer</code> and uses this value in a switch statement to determine which administrative function should be performed. Most of the options here relate to EPDLP functionality that isn&rsquo;t enabled by default - the driver actually contains capability to inject a DLL into userland processes via a Kernel APC, and there are administrative options here to manually trigger that process, or to update a list of excluded processes that shouldn&rsquo;t be hooked.</p><p>In this case we care about the first option, as <code>EpdlpSetUsbAction</code> is where we find our double-fetch. At <code>2</code> we can see some initial validation checks on the arguments supplied, namely that the <code>InputBuffer</code> isn&rsquo;t NULL, and that its length isn&rsquo;t less than 4 bytes. Then at <code>3</code> in the <code>case 1</code> block, there is also a comparison made between the <code>InputBufferLen</code> and a dereferenced value at <code>InputBuffer+4</code>, indicating that we likely have other length fields supplied by the user. The <code>InputBuffer</code> is then passed to <code>EpdlpSetUsbAction</code> as the only argument at <code>4</code>.</p><p><img alt="Disassembly of EpdlpSetUsbAction function" loading=lazy src=/EpdlpSetUsbAction.png#center></p><p>The EPDLP driver maintains a global array of objects that describe mounted volumes on the system. The <code>EpdlpSetUsbAction</code> function, as the name suggests, allows the caller to update a value on a specific one of these objects, determining whether the USB is accessible. The caller supplies the ID (field name <code>DeviceInstanceId</code>) of the target volume as a wide char string in <code>InputBuffer+0x10</code>, along with a corresponding string length at <code>InputBuffer+0xc</code>. The function later loops through the global array of objects and compares the supplied ID in order to find the right one. The <code>DeviceInstanceId</code> contained in the object, however, is a <code>UNICODE_STRING</code>, so the <code>EpdlpSetUsbAction</code> function copies the supplied string into an allocated buffer and constructs the <code>UNICODE_STRING</code> object - and this is where the bug lies.</p><p>As viewable in the function above at <code>1</code>, the supplied string length at <code>InputBuffer+0xc</code> is used as the <code>NumberOfBytes</code> argument in the <code>ExAllocatePoolWithTag</code> function. The returned pointer is assigned as the <code>Buffer</code> value in the new <code>UNICODE_STRING</code>. Then, <code>RtlCopyMemory</code> is called in order to copy the caller supplied string into the heap memory, and the <code>Length</code> argument is a second dereference of <code>InputBuffer+0xc</code>, noted as <code>2</code>.</p><p>This is the double-fetch, and by causing the <code>ExAllocatePoolWithTag</code> call to execute with a <code>NumberOfBytes</code> value that then grows into a larger value by the subsequent <code>RtlCopyMemory</code> call, we can overflow the heap memory with user-supplied data.</p><h2 id=poc>PoC<a hidden class=anchor aria-hidden=true href=#poc>#</a></h2><p>Exploiting a double-fetch for a PoC typically involves a few steps:</p><ol><li>Allocate some memory to use as our input buffer</li><li>Create a &ldquo;flipping&rdquo; thread that runs a while loop that continually XORs the value of a global variable. This global variable will be the value in the buffer that is double-fetched by the driver. (For the purpose of a crash, we can simply XOR the value to make it alternate between a small number and a bigger one.)</li><li>In our main thread, run a function with another while loop that continually calls <code>FilterSendMessage</code> with our input buffer.</li></ol><p>In this particular case, there is one other thing we need to do that I haven&rsquo;t mentioned yet. Astute readers may have noticed earlier that the first <code>FltCreateCommunicationPort</code> call passes a <code>MaxConnections</code> argument with its value set to <code>1</code>. This connection will already be in use by the EPDLP userland service. For us to be able to connect to the port and reach the double-fetch, we need to kill the service to free the connection. Seeing as we need elevated privileges to connect to the communication port, this isn&rsquo;t much of a hurdle. If we didn&rsquo;t need elevated privileges to call the communication port, it would have been worthwhile looking for a way to DoS/restart the EPDLP service as an unprivileged user in order to create a window where the communication port connection is available.</p><p>PoC code is here: <a href=https://github.com/inb1ts/CVE-2024-11616>https://github.com/inb1ts/CVE-2024-11616</a></p><p>Also shoutout to the Netskope PSIRT team who were always responsive and easy to work with throughout the reporting process!</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://www.netskope.com/company/security-compliance-and-assurance/security-advisories-and-disclosures/netskope-security-advisory-nskpsa-2024-003>https://www.netskope.com/company/security-compliance-and-assurance/security-advisories-and-disclosures/netskope-security-advisory-nskpsa-2024-003</a></li><li><a href="https://www.cve.org/CVERecord?id=CVE-2024-11616">https://www.cve.org/CVERecord?id=CVE-2024-11616</a></li><li><a href=https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html>https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html</a></li><li><a href=https://j00ru.vexillium.org/papers/2013/bochspwn.pdf>https://j00ru.vexillium.org/papers/2013/bochspwn.pdf</a></li><li><a href=https://exploits.forsale/24h2-nt-exploit/>https://exploits.forsale/24h2-nt-exploit/</a></li><li><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/communication-between-user-mode-and-kernel-mode>https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/communication-between-user-mode-and-kernel-mode</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/npsvctrig-notes/><span class=title>« Prev</span><br><span>Reversing npsvctrig.sys - Named Pipe Service Triggers</span>
</a><a class=next href=http://localhost:1313/posts/new-tool-csshide/><span class=title>Next »</span><br><span>New Tool: CSSHide - Hiding in plain style</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>Inbits Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>