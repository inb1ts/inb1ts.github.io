<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenFileMapping and KnownDlls | Inbits Blog</title><meta name=keywords content><meta name=description content="A common method of unhooking user-land API hooks is to load a fresh copy of NTDLL from KnownDlls, a special object directory that&rsquo;s used to essentially cache commonly used system DLLs. We can use WinObj to view the Object Manager namespace, where we can see the KnownDlls directory, and the mapped sections it contains for each system DLL.


Whilst working through the excellent Maldev Academy course material, it was pointed out that you can&rsquo;t seem to use OpenFileMapping to retrieve a handle to the KnownDlls directory, despite it&rsquo;s purpose being to open named file mapping objects. Attempting to use the function to open \KnownDlls\ntdll.dll, or any other DLL in that directory, will result in error 161 - ERROR_BAD_PATHNAME. Instead, most malware uses the native NtOpenSection instead."><meta name=author content="Tom Brice"><link rel=canonical href=https://inbits-sec.com/posts/openfilemapping-and-knowndlls/><link crossorigin=anonymous href=/assets/css/stylesheet.min.a8c7cefc3a1d5f4123aa17c5c746a0d812ed0907d1aba94226bb35d21671a605.css integrity="sha256-qMfO/DodX0EjqhfFx0ag2BLtCQfRq6lCJrs10hZxpgU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.555af97124d54bb1457985dd081b8f5616a48103aafeb30ac89fde835d65aa6c.js integrity="sha256-VVr5cSTVS7FFeYXdCBuPVhakgQOq/rMKyJ/eg11lqmw=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://inbits-sec.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://inbits-sec.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://inbits-sec.com/favicon-32x32.png><link rel=apple-touch-icon href=https://inbits-sec.com/apple-touch-icon.png><link rel=mask-icon href=https://inbits-sec.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://inbits-sec.com/posts/openfilemapping-and-knowndlls/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="OpenFileMapping and KnownDlls"><meta property="og:description" content="A common method of unhooking user-land API hooks is to load a fresh copy of NTDLL from KnownDlls, a special object directory that&rsquo;s used to essentially cache commonly used system DLLs. We can use WinObj to view the Object Manager namespace, where we can see the KnownDlls directory, and the mapped sections it contains for each system DLL.


Whilst working through the excellent Maldev Academy course material, it was pointed out that you can&rsquo;t seem to use OpenFileMapping to retrieve a handle to the KnownDlls directory, despite it&rsquo;s purpose being to open named file mapping objects. Attempting to use the function to open \KnownDlls\ntdll.dll, or any other DLL in that directory, will result in error 161 - ERROR_BAD_PATHNAME. Instead, most malware uses the native NtOpenSection instead."><meta property="og:type" content="article"><meta property="og:url" content="https://inbits-sec.com/posts/openfilemapping-and-knowndlls/"><meta property="og:image" content="https://inbits-sec.com/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-17T16:02:16+01:00"><meta property="article:modified_time" content="2023-08-17T16:02:16+01:00"><meta property="og:site_name" content="Inbits"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://inbits-sec.com/"><meta name=twitter:title content="OpenFileMapping and KnownDlls"><meta name=twitter:description content="A common method of unhooking user-land API hooks is to load a fresh copy of NTDLL from KnownDlls, a special object directory that&rsquo;s used to essentially cache commonly used system DLLs. We can use WinObj to view the Object Manager namespace, where we can see the KnownDlls directory, and the mapped sections it contains for each system DLL.


Whilst working through the excellent Maldev Academy course material, it was pointed out that you can&rsquo;t seem to use OpenFileMapping to retrieve a handle to the KnownDlls directory, despite it&rsquo;s purpose being to open named file mapping objects. Attempting to use the function to open \KnownDlls\ntdll.dll, or any other DLL in that directory, will result in error 161 - ERROR_BAD_PATHNAME. Instead, most malware uses the native NtOpenSection instead."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://inbits-sec.com/posts/"},{"@type":"ListItem","position":2,"name":"OpenFileMapping and KnownDlls","item":"https://inbits-sec.com/posts/openfilemapping-and-knowndlls/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenFileMapping and KnownDlls","name":"OpenFileMapping and KnownDlls","description":"A common method of unhooking user-land API hooks is to load a fresh copy of NTDLL from KnownDlls, a special object directory that\u0026rsquo;s used to essentially cache commonly used system DLLs. We can use WinObj to view the Object Manager namespace, where we can see the KnownDlls directory, and the mapped sections it contains for each system DLL.\nWhilst working through the excellent Maldev Academy course material, it was pointed out that you can\u0026rsquo;t seem to use OpenFileMapping to retrieve a handle to the KnownDlls directory, despite it\u0026rsquo;s purpose being to open named file mapping objects. Attempting to use the function to open \\KnownDlls\\ntdll.dll, or any other DLL in that directory, will result in error 161 - ERROR_BAD_PATHNAME. Instead, most malware uses the native NtOpenSection instead.\n","keywords":[],"articleBody":"A common method of unhooking user-land API hooks is to load a fresh copy of NTDLL from KnownDlls, a special object directory that’s used to essentially cache commonly used system DLLs. We can use WinObj to view the Object Manager namespace, where we can see the KnownDlls directory, and the mapped sections it contains for each system DLL.\nWhilst working through the excellent Maldev Academy course material, it was pointed out that you can’t seem to use OpenFileMapping to retrieve a handle to the KnownDlls directory, despite it’s purpose being to open named file mapping objects. Attempting to use the function to open \\KnownDlls\\ntdll.dll, or any other DLL in that directory, will result in error 161 - ERROR_BAD_PATHNAME. Instead, most malware uses the native NtOpenSection instead.\nI wanted to investigate why the function was failing in this manner, and this post is just a short walkthrough what I found.\nOpenFileMapping and NtOpenSection As already mentioned, the OpenFileMapping function “Opens a named file mapping object”. It’s definition is as follows:\nHANDLE OpenFileMappingA( [in] DWORD dwDesiredAccess, [in] BOOL bInheritHandle, [in] LPCSTR lpName ); These parameters are all pretty self-explanatory; dwDesiredAccess specifies the access level for the file mapping object and is checked against the security descriptor on the target object. bInheritHandle specifies whether the handle can be inherited by another process or not. The lpname obviously specifies the name of the file mapping object to be opened, and as noted in the documentation: “The name can have a “Global\" or “Local\" prefix to explicitly open an object in the global or session namespace.”.\nOpenFileMapping eventually calls the native function NtOpenSection, which is used to open a handle for an existing section object:\nNTSYSAPI NTSTATUS ZwOpenSection( [out] PHANDLE SectionHandle, [in] ACCESS_MASK DesiredAccess, [in] POBJECT_ATTRIBUTES ObjectAttributes ); The most relevant parameter here is the pointer to the OBJECT_ATTRIBUTES structure, which is what really holds the meat of what object it is we want to open a handle to:\ntypedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES; So what’s causing the ERROR_BAD_PATHNAME when we call the function with \\KnownDlls\\ntdll.dll?\nA safe assumption is that the issue can be found in the OBJECT_ATTRIBUTES struct that OpenFileMapping is constructing and passing to NtOpenSection. We’ll write a simple program that calls the function, and then set a debugger breakpoint on NtOpenSection to see what is passed in the ObjectAttributes parameter.\nWe know that the NtOpenSection function takes three parameters, and with WinAPI using fastcall, that means the ObjectAttributes pointer argument will be in the R8 register when we hit our breakpoint. Following the pointer in R8 in a memory dump section will lead us to the OBJECT_ATTRIBUTES object being passed:\nLength - red | RootDirectory - green ObjectName - blue | Attributes - orange SecurityDescriptor - pink | SecurityQualityOfService - purple Both of the final parameters are NULL, which is expected - the first one being NULL means the object will receive default security settings, and the second is optional and used to ‘indicate the security impersonal level and context tracking mode,’ which isn’t likely to be causing our issue here. We can check the ObjectName field first and just make sure that the path we are passing to OpenFileMapping is actually what is being passed to NtOpenSection, and isn’t mangled somewhere along the way.\nFollowing the pointer will lead us to a UNICODE_STRING structure which is defined as such:\ntypedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, *PUNICODE_STRING; We can see from debugger comment which has resolved the address of the string that the path is being passed as we expect, and there isn’t anything unusual about the Length or MaximumLength values. Returning to the OBJECT_ATTRIBUTES structure, we are left with two other offending values - the RootDirectory and the Attributes. We can quickly check that the argument passed for the Attributes is 0x80 which is the value for OBJ_OPENIF. This attribute has a kinda confusing explanation in Microsoft’s documentation, but seems to mean that if the object exists a handle to it should be opened, unless the routine is trying to create a new object with that name, in which case it will return an NTSTATUS of STATUS_OBJECT_NAME_COLLISION. If we actually step through the syscall with our debugger to see what is returned from NtOpenSection, we receive a STATUS_OBJECT_PATH_SYNTAX_BAD status, meaning this attribute is unlikely to be what is erroring.\nThat leaves us with the RootDirectory. This is an optional field, which if set to NULL means that the ObjectName field has to point to the fully qualified path to an object. If RootDirectory isn’t NULL, ObjectName will point to an object relative to the RootDirectory. So this quite obviously is what is causing us issues. We are passing in a fully qualified path to an object, \\KnownDlls\\ntdll.dll, which we are expecting to access at the root of the object manager namespace - but NtOpenSection is trying to open this path from presumably a different root. So what location is actually being passed as the RootDirectory? We can have a closer look at what OpenFileMapping is doing to find out:\nThe BaseFormatObjectAttributes jumps out immediately. This function is what constructs our initial OBJECT_ATTRIBUTES structure. If we follow through the execution, we find that it later calls BaseGetNamedObjectDirectory, and this is the value that is set in the RootDirectory field. Some quick searching for this function returns some community documentation from undoc.airesoft.co.uk. The provided overview of the function is that it returns a handle to a named object directory for the current session, in the remarks stating that ’the returned handle may refer to the BaseNamedObject directory if the current user can gain full access to it, or the BaseNamedObjects\\Restricted directory if not.’\nReturning to WinObj will give us a better visual image of the issue this causes:\nThe RootDirectory we are passing is being set to \\Sessions\\1\\BaseNamedObjects\\, and it doesn’t seem possible to traverse back past the root directory and to \\KnownDlls. This can be confirmed by using OpenFileMapping to successfully open a handle to a section included in this directory:\nConclusion + Workaround So that’s it - that’s why you can’t use OpenFileMapping to open the KnownDlls mapped section. Is there a way around it? Yep but it’s a stupid amount of work in order to call OpenFileMapping when you could just call NtOpenSection, and also requires us importing functions from the hokoed version of ntdll.dll - which is exactly what we are trying to bypass. But we’ll do it anyway because who doesn’t love wasting time overengineering solutions to problems that they’ve made up :)\nThe over-the-top workaround is symlinks, as inspired by James Forshaw in https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html.\nWe can create a symlink to to \\GLOBAL?? and then use it in the path to the OpenFileMapping call:\n#include #include #include #define NT_SUCCESS(status) (((NTSTATUS)(status)) \u003e= 0) #define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1) typedef VOID(NTAPI *_RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString); typedef NTSTATUS (WINAPI * _BaseGetNamedObjectDirectory)(HANDLE* phDir); typedef NTSTATUS(NTAPI* _NtCreateSymbolicLinkObject)(PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING TargetName); HANDLE CreateSymlink(LPCWSTR linkname, LPCWSTR targetname) { HANDLE rootDir = NULL; HANDLE hNtdll = GetModuleHandleW(L\"NTDLL\"); NTSTATUS status = NULL; _RtlInitUnicodeString fRtlInitUnicodeString = (_RtlInitUnicodeString) GetProcAddress(hNtdll, \"RtlInitUnicodeString\"); _NtCreateSymbolicLinkObject fNtCreateSymbolicLinkObject = (_NtCreateSymbolicLinkObject) GetProcAddress(hNtdll, \"NtCreateSymbolicLinkObject\"); _BaseGetNamedObjectDirectory fBaseGetNamedObjectDirectory = (_BaseGetNamedObjectDirectory) GetProcAddress(GetModuleHandleW(L\"kernel32\"), \"BaseGetNamedObjectDirectory\"); if (!fRtlInitUnicodeString || !fNtCreateSymbolicLinkObject || !fBaseGetNamedObjectDirectory) { printf(\"[!] Error resolving functions:\\n\"); printf(\"\\tfRtlInitUnicodeString: %x\\n\", fRtlInitUnicodeString); printf(\"\\tfNtCreateSymbolicLinkObject: %x\\n\", fNtCreateSymbolicLinkObject); printf(\"\\tfBaseGetNamedObjectDirectory: %x\\n\",fBaseGetNamedObjectDirectory); return NULL; } OBJECT_ATTRIBUTES objAttr; UNICODE_STRING name; UNICODE_STRING target; HANDLE hLink = NULL; fRtlInitUnicodeString(\u0026name, linkname); fRtlInitUnicodeString(\u0026target, targetname); status = fBaseGetNamedObjectDirectory(\u0026rootDir); if (!NT_SUCCESS(status)) { printf(\"[!] Error calling BaseGetNamedObjectDirectory: %0.8X\\n\", status); return NULL; } InitializeObjectAttributes(\u0026objAttr, \u0026name, OBJ_CASE_INSENSITIVE, rootDir, NULL);\tstatus = fNtCreateSymbolicLinkObject(\u0026hLink, SYMBOLIC_LINK_ALL_ACCESS, \u0026objAttr, \u0026target); if (NT_SUCCESS(status)) { printf(\"[i] Created link %ls -\u003e %ls: %p\\n\", linkname, targetname, hLink); } else { printf(\"[!] Error creating link: %ls -\u003e %ls\\n\", linkname, targetname); } CloseHandle(hNtdll); return hLink; } INT main(VOID) { HANDLE hNtdll = NULL; HANDLE symlinkRedirector = NULL; puts(\"Starting execution. Press enter to continue...\"); getchar(); if (!(symlinkRedirector = CreateSymlink(L\"inbits\", L\"\\\\GLOBAL??\"))) { printf(\"[!] CreateSymlink failed\\n\"); return 1; } hNtdll = OpenFileMappingW(FILE_MAP_READ, FALSE, L\"inbits\\\\GLOBALROOT\\\\KnownDlls\\\\ntdll.dll\"); if (!hNtdll || hNtdll == INVALID_HANDLE_VALUE) { printf(\"[!] OpenFileMappingW failed with error: %d\\n\", GetLastError()); return 1; } printf(\"[i] Opened a handle to ntdll.dll: %x\\n\", hNtdll); getchar(); /* Actually overwrite the hooked ntdll.dll with the clean one */ CloseHandle(symlinkRedirector); CloseHandle(hNtdll); return 0; } ","wordCount":"1379","inLanguage":"en","datePublished":"2023-08-17T16:02:16+01:00","dateModified":"2023-08-17T16:02:16+01:00","author":{"@type":"Person","name":"Tom Brice"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://inbits-sec.com/posts/openfilemapping-and-knowndlls/"},"publisher":{"@type":"Organization","name":"Inbits Blog","logo":{"@type":"ImageObject","url":"https://inbits-sec.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://inbits-sec.com/ accesskey=h title="Inbits Blog (Alt + H)">Inbits Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://inbits-sec.com/about/ title="about me"><span>about me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>OpenFileMapping and KnownDlls</h1><div class=post-meta>&lt;span title='2023-08-17 16:02:16 +0100 BST'>August 17, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;7 min&amp;nbsp;·&amp;nbsp;Tom Brice</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#openfilemapping-and-ntopensection aria-label="OpenFileMapping and NtOpenSection"><code>OpenFileMapping</code> and <code>NtOpenSection</code></a></li><li><a href=#conclusion--workaround aria-label="Conclusion + Workaround">Conclusion + Workaround</a></li></ul></div></details></div><div class=post-content><p>A common method of unhooking user-land API hooks is to load a fresh copy of NTDLL from <code>KnownDlls</code>, a special object directory that&rsquo;s used to essentially cache commonly used system DLLs. We can use <a href=https://learn.microsoft.com/en-us/sysinternals/downloads/winobj target=_blank rel=noopener>WinObj</a> to view the Object Manager namespace, where we can see the <code>KnownDlls</code> directory, and the mapped sections it contains for each system DLL.</p><p><img loading=lazy src=/winobj_knowndlls.png#center alt=WinObj_KnownDlls></p><p>Whilst working through the excellent <a href=https://maldevacademy.com target=_blank rel=noopener>Maldev Academy</a> course material, it was pointed out that you can&rsquo;t seem to use <code>OpenFileMapping</code> to retrieve a handle to the <code>KnownDlls</code> directory, despite it&rsquo;s purpose being to open named file mapping objects. Attempting to use the function to open <code>\KnownDlls\ntdll.dll</code>, or any other DLL in that directory, will result in error 161 - <code>ERROR_BAD_PATHNAME</code>. Instead, most malware uses the native <code>NtOpenSection</code> instead.</p><p>I wanted to investigate why the function was failing in this manner, and this post is just a short walkthrough what I found.</p><hr><h2 id=openfilemapping-and-ntopensection><code>OpenFileMapping</code> and <code>NtOpenSection</code><a hidden class=anchor aria-hidden=true href=#openfilemapping-and-ntopensection>#</a></h2><p>As already mentioned, the <code>OpenFileMapping</code> function &ldquo;Opens a named file mapping object&rdquo;. It&rsquo;s definition is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>HANDLE <span style=color:#a6e22e>OpenFileMappingA</span>(
</span></span><span style=display:flex><span>    [in] DWORD  dwDesiredAccess,
</span></span><span style=display:flex><span>    [in] BOOL   bInheritHandle,
</span></span><span style=display:flex><span>    [in] LPCSTR lpName
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>These parameters are all pretty self-explanatory; <code>dwDesiredAccess</code> specifies the access level for the file mapping object and is checked against the security descriptor on the target object. <code>bInheritHandle</code> specifies whether the handle can be inherited by another process or not. The <code>lpname</code> obviously specifies the name of the file mapping object to be opened, and as noted in the documentation: &ldquo;The name can have a &ldquo;Global" or &ldquo;Local" prefix to explicitly open an object in the global or session namespace.&rdquo;.</p><p><code>OpenFileMapping</code> eventually calls the native function <code>NtOpenSection</code>, which is used to open a handle for an existing section object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>NTSYSAPI NTSTATUS <span style=color:#a6e22e>ZwOpenSection</span>(
</span></span><span style=display:flex><span>    [out] PHANDLE            SectionHandle,
</span></span><span style=display:flex><span>    [in]  ACCESS_MASK        DesiredAccess,
</span></span><span style=display:flex><span>    [in]  POBJECT_ATTRIBUTES ObjectAttributes
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>The most relevant parameter here is the pointer to the <code>OBJECT_ATTRIBUTES</code> structure, which is what really holds the meat of what object it is we want to open a handle to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _OBJECT_ATTRIBUTES {
</span></span><span style=display:flex><span>    ULONG           Length;
</span></span><span style=display:flex><span>    HANDLE          RootDirectory;
</span></span><span style=display:flex><span>    PUNICODE_STRING ObjectName;
</span></span><span style=display:flex><span>    ULONG           Attributes;
</span></span><span style=display:flex><span>    PVOID           SecurityDescriptor;
</span></span><span style=display:flex><span>    PVOID           SecurityQualityOfService;
</span></span><span style=display:flex><span>} OBJECT_ATTRIBUTES;
</span></span></code></pre></div><p>So what&rsquo;s causing the <code>ERROR_BAD_PATHNAME</code> when we call the function with <code>\KnownDlls\ntdll.dll</code>?</p><p>A safe assumption is that the issue can be found in the <code>OBJECT_ATTRIBUTES</code> struct that <code>OpenFileMapping</code> is constructing and passing to <code>NtOpenSection</code>. We&rsquo;ll write a simple program that calls the function, and then set a debugger breakpoint on <code>NtOpenSection</code> to see what is passed in the <code>ObjectAttributes</code> parameter.</p><p><img loading=lazy src=/x64dbg_ntopensection.png#center alt="x64dbg NtOpenSection breakpoint"></p><p>We know that the <code>NtOpenSection</code> function takes three parameters, and with WinAPI using fastcall, that means the <code>ObjectAttributes</code> pointer argument will be in the <code>R8</code> register when we hit our breakpoint. Following the pointer in <code>R8</code> in a memory dump section will lead us to the <code>OBJECT_ATTRIBUTES</code> object being passed:</p><ul><li><code>Length</code> - red | <code>RootDirectory</code> - green</li><li><code>ObjectName</code> - blue | <code>Attributes</code> - orange</li><li><code>SecurityDescriptor</code> - pink | <code>SecurityQualityOfService</code> - purple</li></ul><p><img loading=lazy src=/x64dbg_open_attributes.png#center alt="x64dbg OPEN_ATTRIBUTES"></p><p>Both of the final parameters are <code>NULL</code>, which is expected - the first one being <code>NULL</code> means the object will receive default security settings, and the second is optional and used to &lsquo;indicate the security impersonal level and context tracking mode,&rsquo; which isn&rsquo;t likely to be causing our issue here. We can check the <code>ObjectName</code> field first and just make sure that the path we are passing to <code>OpenFileMapping</code> is actually what is being passed to <code>NtOpenSection</code>, and isn&rsquo;t mangled somewhere along the way.</p><p>Following the pointer will lead us to a <code>UNICODE_STRING</code> structure which is defined as such:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _UNICODE_STRING {
</span></span><span style=display:flex><span>  USHORT Length;
</span></span><span style=display:flex><span>  USHORT MaximumLength;
</span></span><span style=display:flex><span>  PWSTR  Buffer;
</span></span><span style=display:flex><span>} UNICODE_STRING, <span style=color:#f92672>*</span>PUNICODE_STRING;
</span></span></code></pre></div><p><img loading=lazy src=/x64dbg_unicode_string.png#center alt="x64dbg UNICODE_STRING"></p><p>We can see from debugger comment which has resolved the address of the string that the path is being passed as we expect, and there isn&rsquo;t anything unusual about the <code>Length</code> or <code>MaximumLength</code> values. Returning to the <code>OBJECT_ATTRIBUTES</code> structure, we are left with two other offending values - the <code>RootDirectory</code> and the <code>Attributes</code>. We can quickly check that the argument passed for the <code>Attributes</code> is <code>0x80</code> which is the value for <code>OBJ_OPENIF</code>. This attribute has a kinda confusing explanation in Microsoft&rsquo;s documentation, but seems to mean that if the object exists a handle to it should be opened, unless the routine is trying to create a new object with that name, in which case it will return an <code>NTSTATUS</code> of <code>STATUS_OBJECT_NAME_COLLISION</code>. If we actually step through the <code>syscall</code> with our debugger to see what is returned from <code>NtOpenSection</code>, we receive a <code>STATUS_OBJECT_PATH_SYNTAX_BAD</code> status, meaning this attribute is unlikely to be what is erroring.</p><p>That leaves us with the <code>RootDirectory</code>. This is an optional field, which if set to <code>NULL</code> means that the <code>ObjectName</code> field has to point to the fully qualified path to an object. If <code>RootDirectory</code> isn&rsquo;t <code>NULL</code>, <code>ObjectName</code> will point to an object <em>relative</em> to the <code>RootDirectory</code>. So this quite obviously is what is causing us issues. We are passing in a fully qualified path to an object, <code>\KnownDlls\ntdll.dll</code>, which we are expecting to access at the root of the object manager namespace - but <code>NtOpenSection</code> is trying to open this path from presumably a different root. So what location is actually being passed as the <code>RootDirectory</code>? We can have a closer look at what <code>OpenFileMapping</code> is doing to find out:</p><p><img loading=lazy src=/x64dbg_open_file_mapping.png#center alt="x64dbg OpenFileMapping disassembly"></p><p>The <code>BaseFormatObjectAttributes</code> jumps out immediately. This function is what constructs our initial <code>OBJECT_ATTRIBUTES</code> structure. If we follow through the execution, we find that it later calls <code>BaseGetNamedObjectDirectory</code>, and this is the value that is set in the <code>RootDirectory</code> field. Some quick searching for this function returns some community documentation from <a href=http://undoc.airesoft.co.uk/kernel32.dll/BaseGetNamedObjectDirectory.php target=_blank rel=noopener>undoc.airesoft.co.uk</a>. The provided overview of the function is that it returns a handle to a named object directory <strong>for the current session</strong>, in the remarks stating that &rsquo;the returned handle may refer to the <code>BaseNamedObject</code> directory if the current user can gain full access to it, or the <code>BaseNamedObjects\Restricted</code> directory if not.&rsquo;</p><p>Returning to WinObj will give us a better visual image of the issue this causes:</p><p><img loading=lazy src=/winobj_root.png#center alt="WinObj folder structure"></p><p>The <code>RootDirectory</code> we are passing is being set to <code>\Sessions\1\BaseNamedObjects\</code>, and it doesn&rsquo;t seem possible to traverse back past the root directory and to <code>\KnownDlls</code>. This can be confirmed by using <code>OpenFileMapping</code> to successfully open a handle to a section included in this directory:</p><p><img loading=lazy src=/winobj_basenamedobjects.png#center alt="WinObj BaseNamedObjects example">
<img loading=lazy src=/bno_example_open.png#center alt="Opening example relative BNO"></p><h2 id=conclusion--workaround>Conclusion + Workaround<a hidden class=anchor aria-hidden=true href=#conclusion--workaround>#</a></h2><p>So that&rsquo;s it - that&rsquo;s why you can&rsquo;t use <code>OpenFileMapping</code> to open the <code>KnownDlls</code> mapped section. Is there a way around it? Yep but it&rsquo;s a stupid amount of work in order to call <code>OpenFileMapping</code> when you could just call <code>NtOpenSection</code>, and also requires us importing functions from the hokoed version of <code>ntdll.dll</code> - which is exactly what we are trying to bypass. But we&rsquo;ll do it anyway because who doesn&rsquo;t love wasting time overengineering solutions to problems that they&rsquo;ve made up :)</p><p>The over-the-top workaround is symlinks, as inspired by James Forshaw in <a href=https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html target=_blank rel=noopener>https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html</a>.</p><p>We can create a symlink to to <code>\GLOBAL??</code> and then use it in the path to the <code>OpenFileMapping</code> call:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;winternl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NT_SUCCESS(status) (((NTSTATUS)(status)) &gt;= 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>VOID</span>(NTAPI <span style=color:#f92672>*</span>_RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NTSTATUS</span> (WINAPI <span style=color:#f92672>*</span> _BaseGetNamedObjectDirectory)(HANDLE<span style=color:#f92672>*</span> phDir);
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NTSTATUS</span>(NTAPI<span style=color:#f92672>*</span> _NtCreateSymbolicLinkObject)(PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING TargetName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>HANDLE <span style=color:#a6e22e>CreateSymlink</span>(LPCWSTR linkname, LPCWSTR targetname) {
</span></span><span style=display:flex><span>    HANDLE rootDir <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    HANDLE hNtdll <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetModuleHandleW</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;NTDLL&#34;</span>);
</span></span><span style=display:flex><span>    NTSTATUS status <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    _RtlInitUnicodeString fRtlInitUnicodeString <span style=color:#f92672>=</span> (_RtlInitUnicodeString) <span style=color:#a6e22e>GetProcAddress</span>(hNtdll, <span style=color:#e6db74>&#34;RtlInitUnicodeString&#34;</span>);
</span></span><span style=display:flex><span>    _NtCreateSymbolicLinkObject fNtCreateSymbolicLinkObject <span style=color:#f92672>=</span> (_NtCreateSymbolicLinkObject) <span style=color:#a6e22e>GetProcAddress</span>(hNtdll, <span style=color:#e6db74>&#34;NtCreateSymbolicLinkObject&#34;</span>);
</span></span><span style=display:flex><span>    _BaseGetNamedObjectDirectory fBaseGetNamedObjectDirectory <span style=color:#f92672>=</span> (_BaseGetNamedObjectDirectory) <span style=color:#a6e22e>GetProcAddress</span>(<span style=color:#a6e22e>GetModuleHandleW</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;kernel32&#34;</span>), <span style=color:#e6db74>&#34;BaseGetNamedObjectDirectory&#34;</span>);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>fRtlInitUnicodeString <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>fNtCreateSymbolicLinkObject <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>fBaseGetNamedObjectDirectory) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[!] Error resolving functions:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>fRtlInitUnicodeString: %x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, fRtlInitUnicodeString);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>fNtCreateSymbolicLinkObject: %x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, fNtCreateSymbolicLinkObject);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>fBaseGetNamedObjectDirectory: %x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,fBaseGetNamedObjectDirectory);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	OBJECT_ATTRIBUTES objAttr;
</span></span><span style=display:flex><span>	UNICODE_STRING name;
</span></span><span style=display:flex><span>	UNICODE_STRING target;
</span></span><span style=display:flex><span>	HANDLE hLink <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fRtlInitUnicodeString</span>(<span style=color:#f92672>&amp;</span>name, linkname);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fRtlInitUnicodeString</span>(<span style=color:#f92672>&amp;</span>target, targetname);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    status <span style=color:#f92672>=</span> <span style=color:#a6e22e>fBaseGetNamedObjectDirectory</span>(<span style=color:#f92672>&amp;</span>rootDir);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>NT_SUCCESS</span>(status)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[!] Error calling BaseGetNamedObjectDirectory: %0.8X</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, status);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>InitializeObjectAttributes</span>(<span style=color:#f92672>&amp;</span>objAttr, <span style=color:#f92672>&amp;</span>name, OBJ_CASE_INSENSITIVE, rootDir, NULL);	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	status <span style=color:#f92672>=</span> <span style=color:#a6e22e>fNtCreateSymbolicLinkObject</span>(<span style=color:#f92672>&amp;</span>hLink, SYMBOLIC_LINK_ALL_ACCESS, <span style=color:#f92672>&amp;</span>objAttr, <span style=color:#f92672>&amp;</span>target);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>NT_SUCCESS</span>(status)) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[i] Created link %ls -&gt; %ls: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, linkname, targetname, hLink);
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[!] Error creating link: %ls -&gt; %ls</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, linkname, targetname);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CloseHandle</span>(hNtdll);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> hLink;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>INT <span style=color:#a6e22e>main</span>(VOID) {
</span></span><span style=display:flex><span>    HANDLE hNtdll <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    HANDLE symlinkRedirector <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;Starting execution. Press enter to continue...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>getchar</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(symlinkRedirector <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateSymlink</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;inbits&#34;</span>, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>GLOBAL??&#34;</span>))) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[!] CreateSymlink failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    hNtdll <span style=color:#f92672>=</span> <span style=color:#a6e22e>OpenFileMappingW</span>(FILE_MAP_READ, FALSE, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;inbits</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>GLOBALROOT</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>KnownDlls</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>ntdll.dll&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hNtdll <span style=color:#f92672>||</span> hNtdll <span style=color:#f92672>==</span> INVALID_HANDLE_VALUE) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[!] OpenFileMappingW failed with error: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>GetLastError</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[i] Opened a handle to ntdll.dll: %x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, hNtdll);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>getchar</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        Actually overwrite the hooked ntdll.dll with the clean one 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CloseHandle</span>(symlinkRedirector);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CloseHandle</span>(hNtdll);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://inbits-sec.com/posts/new-tool-csshide/><span class=title>« Prev</span><br><span>New Tool: CSSHide - Hiding in plain style</span>
</a><a class=next href=https://inbits-sec.com/posts/in-memory-unhooking/><span class=title>Next »</span><br><span>EDR Unhooking: Patching Falcon hooks without VirtualProtect</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://inbits-sec.com/>Inbits Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>