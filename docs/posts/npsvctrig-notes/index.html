<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reversing npsvctrig.sys - Named Pipe Service Triggers | Inbits Blog</title><meta name=keywords content="windows,reversing"><meta name=description content="This post is a writeup of my notes from reversing npsvctrig.sys. I was recently looking into Service Triggers and couldn&rsquo;t find any writeups or info on this driver - hence sharing this.
Overview

npsvctrig.sys is a native Windows filesystem minifilter driver that implements, as the name suggests, part of the functionality for Named Pipe Service Triggers. The driver is small and straightforward. In a nutshell, it maintains a list of active named pipe triggers, uses minifilter callbacks to intercept specific actions being performed against those named pipes, and then publishes an ETW event containing the name of the pipe when one occurs. The Service Control Manager (SCM) consumes these events, and takes them as an indicator it should start the corresponding service executable."><meta name=author content="Tom Brice"><link rel=canonical href=http://localhost:1313/posts/npsvctrig-notes/><link crossorigin=anonymous href=/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/npsvctrig-notes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://localhost:1313/posts/npsvctrig-notes/"><meta property="og:site_name" content="Inbits Blog"><meta property="og:title" content="Reversing npsvctrig.sys - Named Pipe Service Triggers"><meta property="og:description" content="This post is a writeup of my notes from reversing npsvctrig.sys. I was recently looking into Service Triggers and couldn’t find any writeups or info on this driver - hence sharing this.
Overview npsvctrig.sys is a native Windows filesystem minifilter driver that implements, as the name suggests, part of the functionality for Named Pipe Service Triggers. The driver is small and straightforward. In a nutshell, it maintains a list of active named pipe triggers, uses minifilter callbacks to intercept specific actions being performed against those named pipes, and then publishes an ETW event containing the name of the pipe when one occurs. The Service Control Manager (SCM) consumes these events, and takes them as an indicator it should start the corresponding service executable."><meta property="og:locale" content="en-gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-02T00:00:00+00:00"><meta property="article:modified_time" content="2026-02-02T00:00:00+00:00"><meta property="article:tag" content="Windows"><meta property="article:tag" content="Reversing"><meta property="og:image" content="http://localhost:1313/%3Castro.jpg%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Castro.jpg%3E"><meta name=twitter:title content="Reversing npsvctrig.sys - Named Pipe Service Triggers"><meta name=twitter:description content="This post is a writeup of my notes from reversing npsvctrig.sys. I was recently looking into Service Triggers and couldn&rsquo;t find any writeups or info on this driver - hence sharing this.
Overview

npsvctrig.sys is a native Windows filesystem minifilter driver that implements, as the name suggests, part of the functionality for Named Pipe Service Triggers. The driver is small and straightforward. In a nutshell, it maintains a list of active named pipe triggers, uses minifilter callbacks to intercept specific actions being performed against those named pipes, and then publishes an ETW event containing the name of the pipe when one occurs. The Service Control Manager (SCM) consumes these events, and takes them as an indicator it should start the corresponding service executable."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Reversing npsvctrig.sys - Named Pipe Service Triggers","item":"http://localhost:1313/posts/npsvctrig-notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reversing npsvctrig.sys - Named Pipe Service Triggers","name":"Reversing npsvctrig.sys - Named Pipe Service Triggers","description":"This post is a writeup of my notes from reversing npsvctrig.sys. I was recently looking into Service Triggers and couldn\u0026rsquo;t find any writeups or info on this driver - hence sharing this.\nOverview npsvctrig.sys is a native Windows filesystem minifilter driver that implements, as the name suggests, part of the functionality for Named Pipe Service Triggers. The driver is small and straightforward. In a nutshell, it maintains a list of active named pipe triggers, uses minifilter callbacks to intercept specific actions being performed against those named pipes, and then publishes an ETW event containing the name of the pipe when one occurs. The Service Control Manager (SCM) consumes these events, and takes them as an indicator it should start the corresponding service executable.\n","keywords":["windows","reversing"],"articleBody":"This post is a writeup of my notes from reversing npsvctrig.sys. I was recently looking into Service Triggers and couldn’t find any writeups or info on this driver - hence sharing this.\nOverview npsvctrig.sys is a native Windows filesystem minifilter driver that implements, as the name suggests, part of the functionality for Named Pipe Service Triggers. The driver is small and straightforward. In a nutshell, it maintains a list of active named pipe triggers, uses minifilter callbacks to intercept specific actions being performed against those named pipes, and then publishes an ETW event containing the name of the pipe when one occurs. The Service Control Manager (SCM) consumes these events, and takes them as an indicator it should start the corresponding service executable.\nBreakdown DriverEntry When reversing a Windows driver it nearly always makes the most sense to start with the DriverEntry function. This is where the driver set up is performed, and where we should get an idea of the type of driver we are looking at. This will be often be indicated by the kernel subsystems the driver registers callbacks with. We are also interested in any global objects being initialised and the creation of any device objects that might provide an interface through which we can communicate with the driver.\nIn npsvctrig.sys there are four notable aspects to the DriverEntry function:\nThe registering of a WNF subscriber (via ExSubscribeWnfStateChange) The registering of two ETW publishers (via EtwRegister) The registering of file system minifilter callbacks with the Filter Manager (via FltRegisterFilter) The absence of any device objects being created, or dispatch routines being registered. The first three of these four points actually cover the entire workflow of the driver described in the overview. Here’s an extremely simplified diagram:\nThe driver also allocates some memory for a driver context object that has the following structure:\n// Size 0x40 - Tag 'Nptg' struct DriverContext { PEX_PUSH_LOCK TriggerListLock; // 0x0 LIST_ENTRY TriggerList; // 0x8\tPEX_PUSH_LOCK InstanceListLock; // 0x18 LIST_ENTRY InstanceList; // 0x20 ULONGLONG NamedPipeTimeout; // 0x30 PVOID Reserved; // 0x38 } In this object, the NamedPipeTimeout value is read from \\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\NetworkServiceTriggers\\Config\\NamedPipeTimeout during the initialisation of the object. If that key doesn’t exist, it’s set to a default value of -300000000.\nThe remaining fields will be revisited when looking at the minifilter callbacks.\nOf the two ETW publishers that are registered - one is for the provider that is used to fire the triggers for the SCM subscriber - Microsoft-Windows-EndpointTriggerProvider - and the other appears to be for performance/auditing events, Microsoft-Windows-ServiceTriggerPerfEventProvider. In terms of the logical flow of the named pipe triggers, the former is of the most interest.\nActive Triggers The driver has to maintain an internal list of active triggers that are synchronised with triggers registered with the SCM. This is done via the Windows Notification Facility (WNF). For further reading on WNF, I recommend referring to the work of Yarden Shafir, or Alex Ionescu and Gabrielle Viala’s BlackHat Presentation, though it does not play a substantial role in this driver beyond being used to keep the trigger list up to date.\nRegistering the WNF subscriber and associated callbacks is performed in RtdsRegisterUpdateCallback, called from DriverEntry. Interestingly, the driver contains global variables pertaining to two different WNF State Names - WNF_RTDS_NAMED_PIPE_TRIGGER_CHANGED and WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED - but only the former is actually subscribed to. The function loops through both global objects, but only matches and subscribes to the Named Pipe trigger State Name (unless I’ve completely borked this reversing).\nThe WNF State Name WNF_RTDS_NAMED_PIPE_TRIGGER_CHANGED is published to by services.exe when a new Named Pipe service trigger is created. The state name requires SYSTEM privileges for Read/Write access. The event does not actually provide the name of the newly registered trigger - instead, it prompts the driver to update it’s list from the values in the \\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\NetworkServiceTriggers\\Triggers\\ registry key. A list of objects is created based on the values in RtdspGetTriggerEndpoints, and that list is passed to RtdspGenerateEndpointChangelist, which compares the values against the current list saved to the DriverContext. This produces a third list containing only the triggers that have changed - either new to the driver, or that have been removed from the registry. This third list is passed to NptrigTriggerChangeCallback, where NptrigCreateTrigger is called for ones that are new, and NptrigDestroyTrigger for ones that have been removed.\nThe structure of the trigger object that is created and then saved to the driver object is as follows:\n// Size 0x28 + (name strlen) - Tag 'Nptg' struct Trigger { LIST_ENTRY TriggerList; // 0x0 UNICODE_STRING FileName; // 0x10 ULONG State; // 0x20 WCHAR FileNameBuf[1]; // 0x28 } Upon creation, the default value of the State field is 1.\nMinifilter callbacks Contexts and Instance Attachment When looking at a minifilter registration I like to start by looking at the contexts that are registered at the FLT_CONTEXT_REGISTRATION ContextRegistration field in the FLT_REGISTRATION object. Much of the logic of the driver will be built upon these contexts - in particular, a lot of the control flow will be dictated by flags or options that are held in these objects, so building up a map of them throughout the reverse engineering process is a necessity.\nIn the case of npsvctrig.sys, it only registers an FLT_INSTANCE_CONTEXT entry. This leads nicely to what is often my follow-up task, understanding the InstanceSetupCallback function. This callback will be executed every time a new volume is mounted, and it’s where the minifilter driver decides, based on information about the newly mounted volume, whether it wants to attach itself to the filesystem stack for that volume. This is generally where the previously mentioned FLT_INSTANCE_CONTEXT object will be allocated with FltAllocateContext and the context fields will be populated with information related to the volume.\nThis particular driver, unsurprisingly, only attaches to volumes where the filesystem type is FLT_FSTYPE_NPFS (for Named Pipe File System):\nLittle else of interest happens in this function for this little driver, other than the initialisation of a callback data queue via FltCbdqInitialize. This is a cancel-safe queue that minifilter drivers can use to store callback data from incoming I/O operations. npsvctrig.sys uses this queue to store pending FSCTL_WAIT_PIPE requests, which we will touch more on later.\nOperations The driver only registers three minifilter callbacks, and they are all post-operation:\nPost-Create: NptrigPostCreateCallback Post-CreateNamedPipe: NptrigPostCreateNamedPipeCallback Post-FsControl: NptrigPostFsControlCallback The post-Create and the post-FsControl callbacks serve the purpose of actually publishing an ETW event when the operation has been performed against a named pipe with an associated trigger, assuming certain flags and the right status is set. The post-CreateNamedPipe callback is used to clear any pending requests once the named pipe has been created, and reset the state on the trigger object so that future events can be emitted again.\nNptrigPostCreateCallback The callback starts with checking some input parameter flags and values to determine whether or not it should continue. The Data-\u003eIoStatus.Status == 0xc0000034 assertion checks that the status returned from the Named Pipe filesystem driver npfs.sys is STATUS_OBJECT_NAME_NOT_FOUND. We will also see this same check in the NptrigPostFsControlCallback callback. This might seem self-explanatory, but this highlights that the intent of the named pipe service triggers is that a client asks for a named pipe that is yet to exist, and that the presence of the named pipe indicates the service is already running and doesn’t need to be triggered - in effect, the named pipe is operating a bit like a mutex. The Data-\u003eIopb+0x20 check corresponds to Options-\u003eFILE_DIRECTORY_FILE. This is an interesting check in relation to named pipes, as they don’t really support directories in the traditional sense, but use the flag to implement named pipe prefixes, as described by James Forshaw in his blog post here.\nThe last line in the above screen shot checks that the FILE_OBJECT from the FltObjects input parameter is populated, and that the UNICODE_STRING FileName field on it is not zero-length. This check is here because it’s possible for minifilter callbacks to be intercepting IRP_MJ_CREATE requests where the FileObject is empty, but the RelatedFileObject is populated. This is described in one of the fsfilters blog posts (an amazing resource for anyone looking at minifilters). Specifically, they note a “reopen” case where a new handle is opened to a FILE_OBJECT, specified by an existing handle in the RootDirectory field of the OBJECT_ATTRIBUTES used in the NtCreateFile request.\nAfter these checks, the driver accounts for fact that the filename being opened might start with a backslash (0x5C), essentially skipping over it if it does. This logic is repeated in all of the callbacks:\nNext, the driver loops over the list of triggers it has and checks to see whether the name of the pipe being opened matches any of the names of the triggers. The method of checking is a typical two-step process: first the length of the names are compared, and if they are equal then the contents are compared. One notable point here is that the comparison is made using RtlCompareMemory, meaning that the string comparison is case sensitive - despite service event triggers being generally documented as case insensitive.\nIf a match is found, the driver calls NptrigHandleTriggerableIo, passing in the trigger object from the driver’s list.\nThe purpose of this function is to decide whether or not the trigger should be fired based on the current state of the trigger object. If the state is 1 the trigger will just go ahead and fire. As shown in the decompilation above, if the state is 3, there is a step that modifies the state to 1, before proceeding with the fire. So how does the trigger reach state 3? We’ll revisit that shortly.\nNptrigFireTrigger starts by doing some reordering of the trigger list on the DriverContext, removing and then reinserting the fired trigger at the head of the list. It then sets the State to 2, before actually triggering the ETW event publish.\nIf the fire executes successfully, the driver returns to NptrigPostCreateCallback, and calls NptrigAlterIoStatus. This function takes STATUS_OBJECT_NAME_NOT_FOUND status on the IRP and overwrites it with STATUS_PIPE_NOT_AVAILABLE. FltSetCallbackDataDirty is then called to indicate to any other minifilter drivers further up the altitude list that the FLT_CALLBACK_DATA has been modified whilst travelling back from the filesystem driver.\nNptrigPostFsControlCallback This callback initially shares most of the logic of the post-Create callback, before also queuing a work item that will ensure the IRP status is updated accordingly at the end of the named pipe timeout.\nThe function starts with another check that the status returned from NPFS.sys is STATUS_OBJECT_NAME_NOT_FOUND (0xc0000034). If this is true, it checks that the FsControlCode of the request is 0x110018, corresponding to FSCTL_PIPE_WAIT. It checks that the input buffer length, and the input buffer point, are not null.\nThe expected input object for FSCTL_PIPE_WAIT is a structure with the following layout:\ntypedef struct _FILE_PIPE_WAIT_FOR_BUFFER { LARGE_INTEGER Timeout; ULONG NameLength; BOOLEAN TimeoutSpecified; UCHAR Padding[1]; WCHAR Name[1]; } FILE_PIPE_WAIT_FOR_BUFFER, *PFILE_PIPE_WAIT_FOR_BUFFER; This input structure is retrieved from the FLT_IO_PARAMETER_BLOCK, and it is used to construct a UNICODE_STRING representation of the pipe name being waited upon. As highlighted in the comment, there is truncation as the 4-byte NameLength from the input structure is assigned to the USHORT used for the UNICODE_STRING length, but the NPFS.sys driver quite strictly imposes a 0xFFFD limit on this value, so it doesn’t seem possible to actually achieve this vulnerable condition.\nThe function then passes the UNICODE_STRING pipe name to NptrigFindTrigger, which implements essentially the same logic that is seen in NptrigPostCreateCallback when searching the driver context trigger list for matching entry:\nIf a matching trigger is found, NptrigHandleTriggerableIo is called - the same function that handles the firing of the trigger events in NptrigPostCreateCallback. Upon that call succeeding, this function has one additional step, calling NptrigQueueWaitNamedPipeRequest.\nNptrigQueueWaitNamedPipeRequest The first thing that happens in this function is a call to NptrigCleanupOrphanedWaitNamedPipeRequests, but we’ll revisit it after looking at the caller function first because it’ll make more sense. After this, NptrigQueueWaitNamedPipeRequest allocates a new object that represents a pending request for a named pipe wait. It allocates 0xd0 for the core structure, in additional to the length of the name pipe, which is appended to the end of the buffer. Not all of the fields on this structure seem to be used, but a general layout is:\n// Size 0xd0 + pipe name len - Tag 'Nptg' struct WaitNamedPipeReq { PVOID DpcDeferredContext = Data; // 0x0 PKDPC Dpc; // 0x8 // ... PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Ctx; // 0x48 // ... UNICODE_STRING PipeName; // 0x60 ULONG RefCount; // 0x70 KTIMER * Timer; // 0x78 ULONG DefaultTimeout; // 0xb8 ULONG State; // 0xbc PVOID WorkItem; // 0xc0 PVOID InstanceContext; // 0xc8 WCHAR PipeNameBuffer[1]; // 0xd0 } The State field on this structure is also set to 1 upon initialisation, as with the previous trigger object.\nOnce the object is built, a DPC is initialised with the routine NptrigWaitNamedPipeTimeoutCallback and the WaitNamePipeReq is passed to it as the context. The callback data is inserted in the callback data queue that was initialised in the instance setup, once again with the WaitNamePipeReq attached as context.\nFollowing this there is a check for whether a timeout was specified in the FILE_PIPE_WAIT_FOR_BUFFER input, and whether it falls within an acceptable range. If no timeout was supplied, or one was supplied but is invalid, the value at 0xb8 of the WaitNamedPipeReq object is set to 1, and the default named pipe timeout value that was taken from the registry and saved to the DriverContext is used in the KeSetTimer call for the DPC. Otherwise, the supplied timeout from the input buffer is used for the DueTime in the KeSetTimer call.\nNptrigWaitNamedPipeTimeoutCallback The DPC is minimal, as they are supposed to be, and really exists to queue a work item via FltQueueGenericWorkItem, with the routine NptrigWaitNamedPipeTimeoutWorkItem. A flag at offset 0xbc of the waitNamedPipeReq is used to protect against the DPC being scheduled by multiple cores simultaneously and therefore queuing multiple work items.\nNptrigWaitNamedPipeTimeoutWorkItem This is where the actual purpose of the DPC and work item is carried it - it basically just updates the status on the IRP to one of two outcomes. First the callback data is removed from the callback data queue. Then the 0xb8 field is checked on the WaitNamedPipeReq object that was provided as an a context argument. This field was set to indicate the presence of the default named pipe timeout value. If this field is set, the status of the IRP is set to STATUS_OBJECT_NAME_NOT_FOUND, otherwise it is STATUS_IO_TIMEOUT.\nFltCompletePendedPostOperation is called to signal the post-processing has been completed, and the WaitNamedPipeReq object is dereferenced and then freed.\nIf we revisit NptrigCleanupOrphanedWaitNamedPipeRequests that we saw is called at the beginning of every NptrigQueueWaitNamedPipeRequest call, we find the exact same logic is duplicated there. This function keeps the callback data queue clear of outstanding requests on the same instance, by looping through the queue via FltCbdqRemoveNextIo.\nNptrigPostCreateNamedPipeCallback The last minifilter callback is intended to catch a successful creation of a named pipe that has been triggered, so that any other pending requests can be cancelled and the state on the trigger object can be updated.\nThere’s a check at the beginning that the minifilter isn’t draining, that the status on the IRP has been set to STATUS_SUCCESS by the NPFS.sys driver, and that it’s not a directory open.\nThe function then goes through the same name-matching process against the DriverContext list of triggers. When it finds a successful match, it checks the State field on the trigger object, and if it doesn’t equal 3, then NptrigReleasePendingRequests is called, and the State is updated. This is the final state option, and means we can summarise the state of the triggers as being something like:\nPre-trigger fire Trigger Fired Pipe created NptrigReleasePendingRequests, loops through the callback data queue via FltCbdqRemoveNextIo, but unlike NptrigCleanupOrphanedWaitNamedPipeRequests it provides a PeekContext, passing in the pipe name of the recently created trigger. As such, only pending requests bound for the same object are cancelled - any DPCs are cancelled through KeCancelTimer, work items through FltFreeGenericWorkItem, and the WaitNamedPipeReq is torn down with the pended operation being completed.\nWrap up This covers the general functionality and implementation of the driver. Part of my initial intent for reversing it was that I had been hunting for vulnerabilities in third-party minifilter drivers, and wanted to jump into some native ones now I was more comfortable with them. From a vulnerability research perspective, npsvctrig.sys doesn’t present a huge attack surface. Quite a few of the ways of interacting with the driver require administrator privileges. Most of the non-privileged ways of getting data through the driver pass through other parts of the filesystem stack, where more stringent security checks occur. So I found the driver to be pretty secure - which isn’t a huge surprise given it is very small.\n","wordCount":"2792","inLanguage":"en","image":"http://localhost:1313/%3Castro.jpg%3E","datePublished":"2026-02-02T00:00:00Z","dateModified":"2026-02-02T00:00:00Z","author":{"@type":"Person","name":"Tom Brice"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/npsvctrig-notes/"},"publisher":{"@type":"Organization","name":"Inbits Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Inbits Blog (Alt + H)">Inbits Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title="about me"><span>about me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Reversing npsvctrig.sys - Named Pipe Service Triggers</h1><div class=post-meta><span title='2026-02-02 00:00:00 +0000 UTC'>February 2, 2026</span>&nbsp;·&nbsp;<span>14 min</span>&nbsp;·&nbsp;<span>Tom Brice</span></div></header><div class=post-content><p><em>This post is a writeup of my notes from reversing <code>npsvctrig.sys</code>. I was recently looking into Service Triggers and couldn&rsquo;t find any writeups or info on this driver - hence sharing this.</em></p><h1 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h1><p><img alt="fltmc output" loading=lazy src=/npsvctrig/fltmc_npsvctrig.png#center></p><p><code>npsvctrig.sys</code> is a native Windows filesystem minifilter driver that implements, as the name suggests, part of the functionality for Named Pipe Service Triggers. The driver is small and straightforward. In a nutshell, it maintains a list of active named pipe triggers, uses minifilter callbacks to intercept specific actions being performed against those named pipes, and then publishes an ETW event containing the name of the pipe when one occurs. The Service Control Manager (SCM) consumes these events, and takes them as an indicator it should start the corresponding service executable.</p><h1 id=breakdown>Breakdown<a hidden class=anchor aria-hidden=true href=#breakdown>#</a></h1><h3 id=driverentry><code>DriverEntry</code><a hidden class=anchor aria-hidden=true href=#driverentry>#</a></h3><p>When reversing a Windows driver it nearly always makes the most sense to start with the <code>DriverEntry</code> function. This is where the driver set up is performed, and where we should get an idea of the <em>type</em> of driver we are looking at. This will be often be indicated by the kernel subsystems the driver registers callbacks with. We are also interested in any global objects being initialised and the creation of any device objects that might provide an interface through which we can communicate with the driver.</p><p>In <code>npsvctrig.sys</code> there are four notable aspects to the <code>DriverEntry</code> function:</p><ul><li>The registering of a WNF subscriber (via <code>ExSubscribeWnfStateChange</code>)</li><li>The registering of two ETW publishers (via <code>EtwRegister</code>)</li><li>The registering of file system minifilter callbacks with the Filter Manager (via <code>FltRegisterFilter</code>)</li><li>The absence of any device objects being created, or dispatch routines being registered.</li></ul><p>The first three of these four points actually cover the entire workflow of the driver described in the overview. Here&rsquo;s an extremely simplified diagram:</p><p><img alt="Driver overview" loading=lazy src=/npsvctrig/simplified_diagram.png#center></p><p>The driver also allocates some memory for a driver context object that has the following structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Size 0x40 - Tag &#39;Nptg&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> DriverContext {
</span></span><span style=display:flex><span>	PEX_PUSH_LOCK TriggerListLock;        <span style=color:#75715e>// 0x0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	LIST_ENTRY TriggerList;               <span style=color:#75715e>// 0x8	 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	PEX_PUSH_LOCK InstanceListLock;       <span style=color:#75715e>// 0x18
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	LIST_ENTRY InstanceList;              <span style=color:#75715e>// 0x20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ULONGLONG NamedPipeTimeout;           <span style=color:#75715e>// 0x30
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	PVOID Reserved;                       <span style=color:#75715e>// 0x38
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>In this object, the <code>NamedPipeTimeout</code> value is read from <code>\Registry\Machine\Software\Microsoft\Windows\CurrentVersion\NetworkServiceTriggers\Config\NamedPipeTimeout</code> during the initialisation of the object. If that key doesn&rsquo;t exist, it&rsquo;s set to a default value of <code>-300000000</code>.</p><p>The remaining fields will be revisited when looking at the minifilter callbacks.</p><p>Of the two ETW publishers that are registered - one is for the provider that is used to fire the triggers for the SCM subscriber - <code>Microsoft-Windows-EndpointTriggerProvider</code> - and the other appears to be for performance/auditing events, <code>Microsoft-Windows-ServiceTriggerPerfEventProvider</code>. In terms of the logical flow of the named pipe triggers, the former is of the most interest.</p><h2 id=active-triggers>Active Triggers<a hidden class=anchor aria-hidden=true href=#active-triggers>#</a></h2><p>The driver has to maintain an internal list of active triggers that are synchronised with triggers registered with the SCM. This is done via the Windows Notification Facility (WNF). For further reading on WNF, I recommend referring to the work of <a href=https://blog.trailofbits.com/2023/05/15/introducing-windows-notification-facilitys-wnf-code-integrity/>Yarden Shafir</a>, or Alex Ionescu and Gabrielle Viala&rsquo;s <a href="https://www.youtube.com/watch?v=MybmgE95weo">BlackHat Presentation</a>, though it does not play a substantial role in this driver beyond being used to keep the trigger list up to date.</p><p>Registering the WNF subscriber and associated callbacks is performed in <code>RtdsRegisterUpdateCallback</code>, called from <code>DriverEntry</code>. Interestingly, the driver contains global variables pertaining to two different WNF State Names - <code>WNF_RTDS_NAMED_PIPE_TRIGGER_CHANGED</code> and <code>WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED</code> - but only the former is actually subscribed to. The function loops through both global objects, but only matches and subscribes to the Named Pipe trigger State Name (unless I&rsquo;ve completely borked this reversing).</p><p>The WNF State Name <code>WNF_RTDS_NAMED_PIPE_TRIGGER_CHANGED</code> is published to by <code>services.exe</code> when a new Named Pipe service trigger is created. The state name requires SYSTEM privileges for Read/Write access. The event does not actually provide the name of the newly registered trigger - instead, it prompts the driver to update it&rsquo;s list from the values in the <code>\Registry\Machine\Software\Microsoft\Windows\CurrentVersion\NetworkServiceTriggers\Triggers\</code> registry key. A list of objects is created based on the values in <code>RtdspGetTriggerEndpoints</code>, and that list is passed to <code>RtdspGenerateEndpointChangelist</code>, which compares the values against the current list saved to the <code>DriverContext</code>. This produces a third list containing only the triggers that have changed - either new to the driver, or that have been removed from the registry. This third list is passed to <code>NptrigTriggerChangeCallback</code>, where <code>NptrigCreateTrigger</code> is called for ones that are new, and <code>NptrigDestroyTrigger</code> for ones that have been removed.</p><p>The structure of the trigger object that is created and then saved to the driver object is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Size 0x28 + (name strlen) - Tag &#39;Nptg&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> Trigger {
</span></span><span style=display:flex><span>	LIST_ENTRY TriggerList;                 <span style=color:#75715e>// 0x0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	UNICODE_STRING FileName;                <span style=color:#75715e>// 0x10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ULONG State;                            <span style=color:#75715e>// 0x20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	WCHAR FileNameBuf[<span style=color:#ae81ff>1</span>];                   <span style=color:#75715e>// 0x28
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Upon creation, the default value of the <code>State</code> field is <code>1</code>.</p><h2 id=minifilter-callbacks>Minifilter callbacks<a hidden class=anchor aria-hidden=true href=#minifilter-callbacks>#</a></h2><h3 id=contexts-and-instance-attachment>Contexts and Instance Attachment<a hidden class=anchor aria-hidden=true href=#contexts-and-instance-attachment>#</a></h3><p>When looking at a minifilter registration I like to start by looking at the <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/registering-context-types>contexts</a> that are registered at the <code>FLT_CONTEXT_REGISTRATION ContextRegistration</code> field in the <code>FLT_REGISTRATION</code> object. Much of the logic of the driver will be built upon these contexts - in particular, a lot of the control flow will be dictated by flags or options that are held in these objects, so building up a map of them throughout the reverse engineering process is a necessity.</p><p>In the case of <code>npsvctrig.sys</code>, it only registers an <code>FLT_INSTANCE_CONTEXT</code> entry. This leads nicely to what is often my follow-up task, understanding the <code>InstanceSetupCallback</code> function. This callback will be executed every time a new volume is mounted, and it&rsquo;s where the minifilter driver decides, based on information about the newly mounted volume, whether it wants to attach itself to the filesystem stack for that volume. This is generally where the previously mentioned <code>FLT_INSTANCE_CONTEXT</code> object will be allocated with <code>FltAllocateContext</code> and the context fields will be populated with information related to the volume.</p><p>This particular driver, unsurprisingly, only attaches to volumes where the filesystem type is <code>FLT_FSTYPE_NPFS</code> (for Named Pipe File System):</p><p><img alt=NptrigInstanceSetup loading=lazy src=/npsvctrig/NptrigInstanceSetup.png#center></p><p>Little else of interest happens in this function for this little driver, other than the initialisation of a callback data queue via <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcbdqinitialize><code>FltCbdqInitialize</code></a>. This is a cancel-safe queue that minifilter drivers can use to store callback data from incoming I/O operations. <code>npsvctrig.sys</code> uses this queue to store pending <code>FSCTL_WAIT_PIPE</code> requests, which we will touch more on later.</p><h3 id=operations>Operations<a hidden class=anchor aria-hidden=true href=#operations>#</a></h3><p>The driver only registers three minifilter callbacks, and they are all post-operation:</p><ul><li>Post-Create: <code>NptrigPostCreateCallback</code></li><li>Post-CreateNamedPipe: <code>NptrigPostCreateNamedPipeCallback</code></li><li>Post-FsControl: <code>NptrigPostFsControlCallback</code></li></ul><p>The post-Create and the post-FsControl callbacks serve the purpose of actually publishing an ETW event when the operation has been performed against a named pipe with an associated trigger, assuming certain flags and the right status is set. The post-CreateNamedPipe callback is used to clear any pending requests once the named pipe has been created, and reset the state on the trigger object so that future events can be emitted again.</p><h4 id=nptrigpostcreatecallback><code>NptrigPostCreateCallback</code><a hidden class=anchor aria-hidden=true href=#nptrigpostcreatecallback>#</a></h4><p><img alt="NptrigPostCreateCallback Flags" loading=lazy src=/npsvctrig/NptrigPostCreateCallback_flags.png#center></p><p>The callback starts with checking some input parameter flags and values to determine whether or not it should continue. The <code>Data->IoStatus.Status == 0xc0000034</code> assertion checks that the status returned from the Named Pipe filesystem driver <code>npfs.sys</code> is <code>STATUS_OBJECT_NAME_NOT_FOUND</code>. We will also see this same check in the <code>NptrigPostFsControlCallback</code> callback. This might seem self-explanatory, but this highlights that the intent of the named pipe service triggers is that a client asks for a named pipe that is yet to exist, and that the presence of the named pipe indicates the service is already running and doesn&rsquo;t need to be triggered - in effect, the named pipe is operating a bit like a mutex. The <code>Data->Iopb+0x20</code> check corresponds to <code>Options->FILE_DIRECTORY_FILE</code>. This is an interesting check in relation to named pipes, as they don&rsquo;t really support directories in the traditional sense, but use the flag to implement named pipe prefixes, as described by James Forshaw in <a href=https://www.tiraniddo.dev/2017/11/named-pipe-secure-prefixes.html>his blog post here</a>.</p><p>The last line in the above screen shot checks that the <code>FILE_OBJECT</code> from the <code>FltObjects</code> input parameter is populated, and that the <code>UNICODE_STRING FileName</code> field on it is not zero-length. This check is here because it&rsquo;s possible for minifilter callbacks to be intercepting <code>IRP_MJ_CREATE</code> requests where the <code>FileObject</code> is empty, but the <code>RelatedFileObject</code> is populated. This is described in one of the <em>fsfilters</em> <a href=https://fsfilters.blogspot.com/2011/09/fileobject-names-in-irpmjcreate.html>blog posts</a> (an amazing resource for anyone looking at minifilters). Specifically, they note a &ldquo;reopen&rdquo; case where a new handle is opened to a <code>FILE_OBJECT</code>, specified by an existing handle in the <code>RootDirectory</code> field of the <code>OBJECT_ATTRIBUTES</code> used in the <code>NtCreateFile</code> request.</p><p>After these checks, the driver accounts for fact that the filename being opened might start with a backslash (<code>0x5C</code>), essentially skipping over it if it does. This logic is repeated in all of the callbacks:</p><p><img alt="NptrigPostCreateCallback Backslash" loading=lazy src=/npsvctrig/NptrigPostCreateCallback_backslash.png#center></p><p>Next, the driver loops over the list of triggers it has and checks to see whether the name of the pipe being opened matches any of the names of the triggers. The method of checking is a typical two-step process: first the length of the names are compared, and if they are equal then the contents are compared. One notable point here is that the comparison is made using <code>RtlCompareMemory</code>, meaning that the string comparison is case sensitive - despite service event triggers being generally documented as case insensitive.</p><p><img alt="NptrigPostCreateCallback Name Comparison" loading=lazy src=/npsvctrig/NptrigPostCreateCallback_name_comparison.png#center></p><p>If a match is found, the driver calls <code>NptrigHandleTriggerableIo</code>, passing in the trigger object from the driver&rsquo;s list.</p><p><img alt=NptrigHandleTriggerableIo loading=lazy src=/npsvctrig/NptrigHandleTriggerableIo.png#center></p><p>The purpose of this function is to decide whether or not the trigger should be fired based on the current state of the trigger object. If the state is <code>1</code> the trigger will just go ahead and fire. As shown in the decompilation above, if the state is <code>3</code>, there is a step that modifies the state to <code>1</code>, before proceeding with the fire. So how does the trigger reach state <code>3</code>? We&rsquo;ll revisit that shortly.</p><p><code>NptrigFireTrigger</code> starts by doing some reordering of the trigger list on the <code>DriverContext</code>, removing and then reinserting the fired trigger at the head of the list. It then sets the <code>State</code> to <code>2</code>, before actually triggering the ETW event publish.</p><p>If the fire executes successfully, the driver returns to <code>NptrigPostCreateCallback</code>, and calls <code>NptrigAlterIoStatus</code>. This function takes <code>STATUS_OBJECT_NAME_NOT_FOUND</code> status on the IRP and overwrites it with <code>STATUS_PIPE_NOT_AVAILABLE</code>. <code>FltSetCallbackDataDirty</code> is then called to indicate to any other minifilter drivers further up the altitude list that the <code>FLT_CALLBACK_DATA</code> has been modified whilst travelling back from the filesystem driver.</p><h4 id=nptrigpostfscontrolcallback><code>NptrigPostFsControlCallback</code><a hidden class=anchor aria-hidden=true href=#nptrigpostfscontrolcallback>#</a></h4><p>This callback initially shares most of the logic of the post-Create callback, before also queuing a work item that will ensure the IRP status is updated accordingly at the end of the named pipe timeout.</p><p>The function starts with another check that the status returned from <code>NPFS.sys</code> is <code>STATUS_OBJECT_NAME_NOT_FOUND</code> (0xc0000034). If this is true, it checks that the <code>FsControlCode</code> of the request is <code>0x110018</code>, corresponding to <code>FSCTL_PIPE_WAIT</code>. It checks that the input buffer length, and the input buffer point, are not null.</p><p>The expected input object for <code>FSCTL_PIPE_WAIT</code> is a structure with the <a href=https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/f030a3b9-539c-4c7b-a893-86b795b9b711>following layout</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _FILE_PIPE_WAIT_FOR_BUFFER {
</span></span><span style=display:flex><span>    LARGE_INTEGER Timeout;
</span></span><span style=display:flex><span>    ULONG NameLength;
</span></span><span style=display:flex><span>    BOOLEAN TimeoutSpecified;
</span></span><span style=display:flex><span>    UCHAR Padding[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    WCHAR Name[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>} FILE_PIPE_WAIT_FOR_BUFFER, <span style=color:#f92672>*</span>PFILE_PIPE_WAIT_FOR_BUFFER;
</span></span></code></pre></div><p><img alt="NptrigPostFsControlCallback Input Buffer" loading=lazy src=/npsvctrig/NptrigPostFsControlCallback_input_buffer.png#center></p><p>This input structure is retrieved from the <code>FLT_IO_PARAMETER_BLOCK</code>, and it is used to construct a <code>UNICODE_STRING</code> representation of the pipe name being waited upon. As highlighted in the comment, there is truncation as the 4-byte <code>NameLength</code> from the input structure is assigned to the <code>USHORT</code> used for the <code>UNICODE_STRING</code> length, but the <code>NPFS.sys</code> driver quite strictly imposes a <code>0xFFFD</code> limit on this value, so it doesn&rsquo;t seem possible to actually achieve this vulnerable condition.</p><p>The function then passes the <code>UNICODE_STRING</code> pipe name to <code>NptrigFindTrigger</code>, which implements essentially the same logic that is seen in <code>NptrigPostCreateCallback</code> when searching the driver context trigger list for matching entry:</p><p><img alt=NptrigFindTrigger loading=lazy src=/npsvctrig/NptrigFindTrigger.png#center></p><p>If a matching trigger is found, <code>NptrigHandleTriggerableIo</code> is called - the same function that handles the firing of the trigger events in <code>NptrigPostCreateCallback</code>. Upon that call succeeding, this function has one additional step, calling <code>NptrigQueueWaitNamedPipeRequest</code>.</p><h5 id=nptrigqueuewaitnamedpiperequest><code>NptrigQueueWaitNamedPipeRequest</code><a hidden class=anchor aria-hidden=true href=#nptrigqueuewaitnamedpiperequest>#</a></h5><p>The first thing that happens in this function is a call to <code>NptrigCleanupOrphanedWaitNamedPipeRequests</code>, but we&rsquo;ll revisit it after looking at the caller function first because it&rsquo;ll make more sense. After this, <code>NptrigQueueWaitNamedPipeRequest</code> allocates a new object that represents a pending request for a named pipe wait. It allocates <code>0xd0</code> for the core structure, in additional to the length of the name pipe, which is appended to the end of the buffer. Not all of the fields on this structure seem to be used, but a general layout is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Size 0xd0 + pipe name len - Tag &#39;Nptg&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> WaitNamedPipeReq {
</span></span><span style=display:flex><span>	PVOID DpcDeferredContext <span style=color:#f92672>=</span> Data;          <span style=color:#75715e>// 0x0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	PKDPC Dpc;                                <span style=color:#75715e>// 0x8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Ctx;  <span style=color:#75715e>// 0x48
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	UNICODE_STRING PipeName;                  <span style=color:#75715e>// 0x60
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ULONG RefCount;                           <span style=color:#75715e>// 0x70
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	KTIMER <span style=color:#f92672>*</span> Timer;                           <span style=color:#75715e>// 0x78
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	ULONG DefaultTimeout;                     <span style=color:#75715e>// 0xb8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ULONG State;                              <span style=color:#75715e>// 0xbc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	PVOID WorkItem;                           <span style=color:#75715e>// 0xc0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	PVOID InstanceContext;                    <span style=color:#75715e>// 0xc8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	WCHAR PipeNameBuffer[<span style=color:#ae81ff>1</span>];                  <span style=color:#75715e>// 0xd0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The <code>State</code> field on this structure is also set to <code>1</code> upon initialisation, as with the previous trigger object.</p><p>Once the object is built, a DPC is initialised with the routine <code>NptrigWaitNamedPipeTimeoutCallback</code> and the <code>WaitNamePipeReq</code> is passed to it as the context. The callback data is inserted in the callback data queue that was initialised in the instance setup, once again with the <code>WaitNamePipeReq</code> attached as context.</p><p>Following this there is a check for whether a timeout was specified in the <code>FILE_PIPE_WAIT_FOR_BUFFER</code> input, and whether it falls within an acceptable range. If no timeout was supplied, or one was supplied but is invalid, the value at <code>0xb8</code> of the <code>WaitNamedPipeReq</code> object is set to <code>1</code>, and the default named pipe timeout value that was taken from the registry and saved to the <code>DriverContext</code> is used in the <code>KeSetTimer</code> call for the DPC. Otherwise, the supplied timeout from the input buffer is used for the <code>DueTime</code> in the <code>KeSetTimer</code> call.</p><h5 id=nptrigwaitnamedpipetimeoutcallback><code>NptrigWaitNamedPipeTimeoutCallback</code><a hidden class=anchor aria-hidden=true href=#nptrigwaitnamedpipetimeoutcallback>#</a></h5><p>The DPC is minimal, as they are supposed to be, and really exists to queue a work item via <code>FltQueueGenericWorkItem</code>, with the routine <code>NptrigWaitNamedPipeTimeoutWorkItem</code>. A flag at offset <code>0xbc</code> of the <code>waitNamedPipeReq</code> is used to protect against the DPC being scheduled by multiple cores simultaneously and therefore queuing multiple work items.</p><p><img alt="NptrigWaitNamedPipeTimeoutCallback DPC Handling" loading=lazy src=/npsvctrig/NptrigWaitNamedPipeTimeoutCallback_DPC_handling.png#center></p><h5 id=nptrigwaitnamedpipetimeoutworkitem><code>NptrigWaitNamedPipeTimeoutWorkItem</code><a hidden class=anchor aria-hidden=true href=#nptrigwaitnamedpipetimeoutworkitem>#</a></h5><p>This is where the actual purpose of the DPC and work item is carried it - it basically just updates the status on the IRP to one of two outcomes. First the callback data is removed from the callback data queue. Then the <code>0xb8</code> field is checked on the <code>WaitNamedPipeReq</code> object that was provided as an a context argument. This field was set to indicate the presence of the default named pipe timeout value. If this field is set, the status of the IRP is set to <code>STATUS_OBJECT_NAME_NOT_FOUND</code>, otherwise it is <code>STATUS_IO_TIMEOUT</code>.</p><p><img alt="Timeout Cancel Check" loading=lazy src=/npsvctrig/timeout_cancel_check.png#center></p><p><code>FltCompletePendedPostOperation</code> is called to signal the post-processing has been completed, and the <code>WaitNamedPipeReq</code> object is dereferenced and then freed.</p><p>If we revisit <code>NptrigCleanupOrphanedWaitNamedPipeRequests</code> that we saw is called at the beginning of every <code>NptrigQueueWaitNamedPipeRequest</code> call, we find the exact same logic is duplicated there. This function keeps the callback data queue clear of outstanding requests on the same instance, by looping through the queue via <code>FltCbdqRemoveNextIo</code>.</p><h4 id=nptrigpostcreatenamedpipecallback><code>NptrigPostCreateNamedPipeCallback</code><a hidden class=anchor aria-hidden=true href=#nptrigpostcreatenamedpipecallback>#</a></h4><p>The last minifilter callback is intended to catch a successful creation of a named pipe that has been triggered, so that any other pending requests can be cancelled and the state on the trigger object can be updated.</p><p><img alt="NptrigPostCreateNamedPipe Flags" loading=lazy src=/npsvctrig/NptrigPostCreateNamedPipe_flags.png#center></p><p>There&rsquo;s a check at the beginning that the minifilter isn&rsquo;t draining, that the status on the IRP has been set to <code>STATUS_SUCCESS</code> by the <code>NPFS.sys</code> driver, and that it&rsquo;s not a directory open.</p><p><img alt="NptrigPostCreatenamedPipeCallback Match" loading=lazy src=/npsvctrig/NptrigPostCreateNamedPipeCallback_match.png#center></p><p>The function then goes through the same name-matching process against the <code>DriverContext</code> list of triggers. When it finds a successful match, it checks the <code>State</code> field on the trigger object, and if it doesn&rsquo;t equal <code>3</code>, then <code>NptrigReleasePendingRequests</code> is called, and the <code>State</code> is updated. This is the final state option, and means we can summarise the state of the triggers as being something like:</p><ol><li>Pre-trigger fire</li><li>Trigger Fired</li><li>Pipe created</li></ol><p><code>NptrigReleasePendingRequests</code>, loops through the callback data queue via <code>FltCbdqRemoveNextIo</code>, but unlike <code>NptrigCleanupOrphanedWaitNamedPipeRequests</code> it provides a <code>PeekContext</code>, passing in the pipe name of the recently created trigger. As such, only pending requests bound for the same object are cancelled - any DPCs are cancelled through <code>KeCancelTimer</code>, work items through <code>FltFreeGenericWorkItem</code>, and the <code>WaitNamedPipeReq</code> is torn down with the pended operation being completed.</p><hr><h1 id=wrap-up>Wrap up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h1><p>This covers the general functionality and implementation of the driver. Part of my initial intent for reversing it was that I had been hunting for vulnerabilities in third-party minifilter drivers, and wanted to jump into some native ones now I was more comfortable with them. From a vulnerability research perspective, <code>npsvctrig.sys</code> doesn&rsquo;t present a huge attack surface. Quite a few of the ways of interacting with the driver require administrator privileges. Most of the non-privileged ways of getting data through the driver pass through other parts of the filesystem stack, where more stringent security checks occur. So I found the driver to be pretty secure - which isn&rsquo;t a huge surprise given it is very small.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/windows/>Windows</a></li><li><a href=http://localhost:1313/tags/reversing/>Reversing</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/cve-2024-11616-netskope/><span class=title>Next »</span><br><span>CVE-2024-11616: Netskope EPDLP Double-Fetch</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>Inbits Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>