<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CVE-2026-20820 Root Cause Analysis | Inbits Blog</title><meta name=keywords content><meta name=description content="CVE-2026-20820 is a vulnerability in the Common Log File System (CLFS) driver that was included in the January 2026 Patch Tuesday. The advisory lists it as a heap overflow that can be used for EoP.
CLFS.sys has a rich history of vulnerabilities and exploits, but a lot of them historically have involved modifying or corrupting the BLF files parsed by the driver. I hadn&rsquo;t looked into CLFS in much detail before, so I thought doing some n-day analysis would be a good framing exercise to gain some familiarity. I also noticed in the docs the mention of Authentication Codes, a relatively recent hardening feature that was added with the intent of mitigating the type of exploits that modify the BLF files. So I was curious as to what other areas of attack surface were still yielding bugs that are capable of being used for EoP."><meta name=author content="Tom Brice"><link rel=canonical href=https://inbits-sec.com/posts/cve-2026-20820-root-cause/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://inbits-sec.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://inbits-sec.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://inbits-sec.com/favicon-32x32.png><link rel=apple-touch-icon href=https://inbits-sec.com/apple-touch-icon.png><link rel=mask-icon href=https://inbits-sec.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://inbits-sec.com/posts/cve-2026-20820-root-cause/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://inbits-sec.com/posts/cve-2026-20820-root-cause/"><meta property="og:site_name" content="Inbits Blog"><meta property="og:title" content="CVE-2026-20820 Root Cause Analysis"><meta property="og:description" content="CVE-2026-20820 is a vulnerability in the Common Log File System (CLFS) driver that was included in the January 2026 Patch Tuesday. The advisory lists it as a heap overflow that can be used for EoP.
CLFS.sys has a rich history of vulnerabilities and exploits, but a lot of them historically have involved modifying or corrupting the BLF files parsed by the driver. I hadn’t looked into CLFS in much detail before, so I thought doing some n-day analysis would be a good framing exercise to gain some familiarity. I also noticed in the docs the mention of Authentication Codes, a relatively recent hardening feature that was added with the intent of mitigating the type of exploits that modify the BLF files. So I was curious as to what other areas of attack surface were still yielding bugs that are capable of being used for EoP."><meta property="og:locale" content="en-gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-02T13:02:29+00:00"><meta property="article:modified_time" content="2026-02-02T13:02:29+00:00"><meta property="og:image" content="https://inbits-sec.com/%3Castro.jpg%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://inbits-sec.com/%3Castro.jpg%3E"><meta name=twitter:title content="CVE-2026-20820 Root Cause Analysis"><meta name=twitter:description content="CVE-2026-20820 is a vulnerability in the Common Log File System (CLFS) driver that was included in the January 2026 Patch Tuesday. The advisory lists it as a heap overflow that can be used for EoP.
CLFS.sys has a rich history of vulnerabilities and exploits, but a lot of them historically have involved modifying or corrupting the BLF files parsed by the driver. I hadn&rsquo;t looked into CLFS in much detail before, so I thought doing some n-day analysis would be a good framing exercise to gain some familiarity. I also noticed in the docs the mention of Authentication Codes, a relatively recent hardening feature that was added with the intent of mitigating the type of exploits that modify the BLF files. So I was curious as to what other areas of attack surface were still yielding bugs that are capable of being used for EoP."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://inbits-sec.com/posts/"},{"@type":"ListItem","position":2,"name":"CVE-2026-20820 Root Cause Analysis","item":"https://inbits-sec.com/posts/cve-2026-20820-root-cause/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CVE-2026-20820 Root Cause Analysis","name":"CVE-2026-20820 Root Cause Analysis","description":"CVE-2026-20820 is a vulnerability in the Common Log File System (CLFS) driver that was included in the January 2026 Patch Tuesday. The advisory lists it as a heap overflow that can be used for EoP.\nCLFS.sys has a rich history of vulnerabilities and exploits, but a lot of them historically have involved modifying or corrupting the BLF files parsed by the driver. I hadn\u0026rsquo;t looked into CLFS in much detail before, so I thought doing some n-day analysis would be a good framing exercise to gain some familiarity. I also noticed in the docs the mention of Authentication Codes, a relatively recent hardening feature that was added with the intent of mitigating the type of exploits that modify the BLF files. So I was curious as to what other areas of attack surface were still yielding bugs that are capable of being used for EoP.\n","keywords":[],"articleBody":"CVE-2026-20820 is a vulnerability in the Common Log File System (CLFS) driver that was included in the January 2026 Patch Tuesday. The advisory lists it as a heap overflow that can be used for EoP.\nCLFS.sys has a rich history of vulnerabilities and exploits, but a lot of them historically have involved modifying or corrupting the BLF files parsed by the driver. I hadn’t looked into CLFS in much detail before, so I thought doing some n-day analysis would be a good framing exercise to gain some familiarity. I also noticed in the docs the mention of Authentication Codes, a relatively recent hardening feature that was added with the intent of mitigating the type of exploits that modify the BLF files. So I was curious as to what other areas of attack surface were still yielding bugs that are capable of being used for EoP.\nIt was clear from many of the writeups of previous vulns and associated exploits that there’s a fair bit of complexity in CLFS, along with quite a range of undocumented (officially) types - so I was braced for the vulnerability analysis to be a bit of a mission. As it turned out though, the lack of changes in the diff made it quite straightforward…\nDiffing Only one changed function. That’s handy.\nVulnerability Root Cause So in the CclfsRequest::ScanContainers function, we have the addition of two blocks. If we take a quick look at the assembly in those blocks, just within BinDiff, we can get an early sense of what bug we’ll be looking for when we move over to the decompilation:\nUpon entering this new block, r15d will be holding a value taken from the input buffer (we’ll explore what exactly, soon), or it will hold 0xffffffff if that user value exceeds 0xffffffff. What we then see is essentially a user input value having 0x38 added to it, and this value being bounds checked. There is a check to determine whether or not the value has wrapped around, that will result in a 0xc0000095 error, indication an Integer overflow.\nIt’s probably easier to move over to the decompilation to dig into this further, and when we do it’s pretty obvious where this additional block is, both from the check of the value adjusted by 0x38, and also the feature flag check function call, commonly used in staged rollouts of patches.\nWe still haven’t gone over the context surrounding where we are in the driver and what objects are being handled, but I’ll quickly go over the patch because it’s really just a bounds-checking issue.\nAt 1. it’s important to know that ContainerCount is the user supplied value that I alluded to in when looking at the assembly. This count value is taken from the input buffer, and as it probably obvious at this point, is taken as to specify how many objects the caller is querying information about. This count is multiplied by 0x240, which is the size of the container objects being returned. These objects are of type _CLS_CONTAINER_INFORMATION. So in effect, for this expression is intended to result in the expected length of the data being retrieved and written to the output. It’s worth noting this value is 8-byte integer.\nAt 2. there are two variables, at least in the way Binja is displaying the decompilation, with the important point being they are initialised to 0xFFFFFFFF, the maximum size available in a 4-byte unsigned integer.\nAt 3. and 4. the calculated expected output length is checked against this upper bound of 0xFFFFFFFF, and if it’s of a lower value, then the calculated value is fine to proceed with. If it’s greater (or actually equal to), the check at 4. results in the INTEGER_OVERFLOW error being returned.\nAt 5. the calculated value is retained in a new variable, and a new variable is initialised that holds the value with the addition of 0x38. This adjusted value is compared to the initial value at 6., and this only really makes sense to me as an additional overflow check. Interestingly though, I don’t actually think this value could overflow, as 0xFFFFFFFF when divided by the 0x240 size doesn’t land close enough to the upper boundary to be overflowed by the + 0x38. Regardless, it is expected that the adjusted length will be greater than the initial value, and if that is case then at 7. our “final” variable is filled with the adjusted value. 8. shows that if there is an overflow, the INTEGER_OVERFLOW status is returned.\nAnd finally, at 9., there is a key check, that this adjusted value is greater than the OutputBufferLength passed in the I/O call to the driver.\nHere is a comparison with the same function, pre-patch:\nSo yeah - there are no checks made against the ExpectedOutLen with the addition of the 0x38 bytes. So we can reasonable assume that we likely have an overflow of some sort by up to 0x38 bytes past the end of a buffer.\nSo what is the 0x38 bytes?\nWell, it’s the context object for the I/O call - specifically, CLS_SCAN_CONTEXT. It is read from the “output” buffer, as essentially the input to the call, and then that same buffer is used to copy the output into. This might seem confusing given the separation of input/output buffers in DeviceIoControl calls, but it is related to the I/O method used for this specific call. The CClfsRequest::ScanContainers function is reached via the IOCTL 0x80076816. Once decoded, this code specifies the buffer method as METHOD_OUT_DIRECT. What this means it that:\nInput buffer = Buffered I/O Output buffer = Direct I/O When Direct I/O is selected for a buffer management method, the I/O Manager brings the user supplied buffer into physical memory and locks it so it can’t be paged out. The I/O Manager the prepares an MDL and assigns a pointer to it to Ipr-\u003eMdlAddress. I’m not sure if this is actually documented by Microsoft anywhere, but Pavel at least points out in his kernel programming course that the Direct I/O output buffer really can be (and clearly is) used as both the input and the output buffer in certain cases.\nThe CLS_SCAN_CONTEXT object has the following definition:\ntypedef struct _CLS_SCAN_CONTEXT { CLFS_NODE_ID cidNode; // 0x0 PLOG_FILE_OBJECT plfoLog; // 0x8 ULONG cIndex; // 0x10 ULONG cContainers; // 0x18 ULONG cContainersReturned; // 0x20 CLFS_SCAN_MODE eScanMode; // 0x28 PCLS_CONTAINER_INFORMATION pinfoContainer; // 0x30 } CLS_SCAN_CONTEXT, *PCLS_SCAN_CONTEXT, PPCLS_SCAN_CONTEXT; So the root cause of the vulnerability is that, when calculating whether the requested number of container objects fits within the size of the output buffer, the function does not take into consideration that 0x38 bytes of that output buffer are already taken up by the preceding context object.\nThis means that the last 0x38 bytes of a CLS_CONTAINER_INFORMATION object can be written outside the bounds of the output buffer. If we look at the CLS_CONTAINER_INFORMATION definition:\ntypedef struct _CLS_CONTAINER_INFORMATION { ULONG FileAttributes; // 0x0 ULONGLONG CreationTime; // 0x8 ULONGLONG LastAccessTime; // 0x10 ULONGLONG LastWriteTime; // 0x18 LONGLONG ContainerSize; // 0x20 ULONG FileNameActualLength; // 0x28 ULONG FileNameLength; // 0x2C WCHAR FileName[CLFS_MAX_CONTAINER_INFO]; // 0x30 CLFS_CONTAINER_STATE State; // 0x230 CLFS_CONTAINER_ID PhysicalContainerId; // 0x234 CLFS_CONTAINER_ID LogicalContainerId; // 0x238 } CLS_CONTAINER_INFORMATION, *PCLS_CONTAINER_INFORMATION; This ends up being the State, PhysicalContainerId, and the LogicalContainerId, and the final 0x28 bytes of the FileName.\nThese fields are written to a couple of functions later, in CClfsBaseFile::ScanContainerInfo.\nExploit Feasibility We can quite easily get this to cause a BSOD as an initial PoC that the vulnerability exists. The most straight forward way is to position our user-land buffer at the end of a page of memory, with a guard page adjacent to it. When the driver attempts to write beyond the end of the legitimate buffer, and into the guard page, it will produce a page fault that can’t be handled by the kernel, resulting a BSOD.\nThis works as expected:\nAt this point, however, I got a bit confused by the MSRC advisory. The advisory categorises the CVE as a heap-based buffer overflow - but what we are seeing here isn’t really that, it’s an overflow of the System PTE pages, into a user-land buffer. Looking around online, and sending an LLM off to do the same thing, didn’t yield any examples to me of exploits overflowing virtual memory that is mapped for these MDLs.\nIt’s possible that I’ve misinterpreted the bug ¯\\_(ツ)_/¯, or that I’m overlooking some controllable aspect of the I/O request, that changes where this overflow takes place. Alternatively, the MSRC categorisation might be inaccurate, or there’s some technique unknown to me for controlling/influencing where this overflow occurs. Please reach out to me and let me know if this is the case.\n","wordCount":"1444","inLanguage":"en","image":"https://inbits-sec.com/%3Castro.jpg%3E","datePublished":"2026-02-02T13:02:29Z","dateModified":"2026-02-02T13:02:29Z","author":{"@type":"Person","name":"Tom Brice"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://inbits-sec.com/posts/cve-2026-20820-root-cause/"},"publisher":{"@type":"Organization","name":"Inbits Blog","logo":{"@type":"ImageObject","url":"https://inbits-sec.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://inbits-sec.com/ accesskey=h title="Inbits Blog (Alt + H)">Inbits Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://inbits-sec.com/about/ title="about me"><span>about me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CVE-2026-20820 Root Cause Analysis</h1><div class=post-meta><span title='2026-02-02 13:02:29 +0000 UTC'>February 2, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Tom Brice</span></div></header><div class=post-content><p>CVE-2026-20820 is a vulnerability in the Common Log File System (CLFS) driver that was included in the January 2026 Patch Tuesday. The <a href=https://msrc.microsoft.com/update-guide/vulnerability/CVE-2026-20820>advisory</a> lists it as a heap overflow that can be used for EoP.</p><p><code>CLFS.sys</code> has a rich history of vulnerabilities and exploits, but a lot of them historically have involved modifying or corrupting the BLF files parsed by the driver. I hadn&rsquo;t looked into CLFS in much detail before, so I thought doing some n-day analysis would be a good framing exercise to gain some familiarity. I also noticed in the docs the mention of <a href=https://support.microsoft.com/en-gb/topic/common-log-file-system-clfs-authentication-mitigation-af903a7e-ceca-410e-a5bf-58b1c79e861d>Authentication Codes</a>, a relatively recent hardening feature that was added with the intent of mitigating the type of exploits that modify the BLF files. So I was curious as to what other areas of attack surface were still yielding bugs that are capable of being used for EoP.</p><p>It was clear from many of the writeups of previous vulns and associated exploits that there&rsquo;s a fair bit of complexity in CLFS, along with quite a range of undocumented (officially) types - so I was braced for the vulnerability analysis to be a bit of a mission. As it turned out though, the lack of changes in the diff made it quite straightforward&mldr;</p><h2 id=diffing>Diffing<a hidden class=anchor aria-hidden=true href=#diffing>#</a></h2><p><img alt="Diff Similarity" loading=lazy src=/CVE-2026-20820/diff_similarity.png#center></p><p>Only one changed function. That&rsquo;s handy.</p><p><img alt="Diff Graph View" loading=lazy src=/CVE-2026-20820/diff_graph_view.png#center></p><h2 id=vulnerability-root-cause>Vulnerability Root Cause<a hidden class=anchor aria-hidden=true href=#vulnerability-root-cause>#</a></h2><p>So in the <code>CclfsRequest::ScanContainers</code> function, we have the addition of two blocks. If we take a quick look at the assembly in those blocks, just within BinDiff, we can get an early sense of what bug we&rsquo;ll be looking for when we move over to the decompilation:</p><p><img alt="Diff New Blocks ASM" loading=lazy src=/CVE-2026-20820/bindiff_new_blocks_asm.png#center></p><p>Upon entering this new block, <code>r15d</code> will be holding a value taken from the input buffer (we&rsquo;ll explore what exactly, soon), or it will hold <code>0xffffffff</code> if that user value exceeds <code>0xffffffff</code>. What we then see is essentially a user input value having <code>0x38</code> added to it, and this value being bounds checked. There is a check to determine whether or not the value has wrapped around, that will result in a <code>0xc0000095</code> error, indication an <code>Integer overflow</code>.</p><p>It&rsquo;s probably easier to move over to the decompilation to dig into this further, and when we do it&rsquo;s pretty obvious where this additional block is, both from the check of the value adjusted by <code>0x38</code>, and also the feature flag check function call, commonly used in staged rollouts of patches.</p><p><img alt="ScanContainers Patched" loading=lazy src=/CVE-2026-20820/scancontainers_patched.png#center></p><p>We still haven&rsquo;t gone over the context surrounding where we are in the driver and what objects are being handled, but I&rsquo;ll quickly go over the patch because it&rsquo;s really just a bounds-checking issue.</p><p>At <code>1.</code> it&rsquo;s important to know that <code>ContainerCount</code> is the user supplied value that I alluded to in when looking at the assembly. This count value is taken from the input buffer, and as it probably obvious at this point, is taken as to specify <em>how many</em> objects the caller is querying information about. This count is multiplied by <code>0x240</code>, which is the size of the container objects being returned. These objects are of type <code>_CLS_CONTAINER_INFORMATION</code>. So in effect, for this expression is intended to result in the expected length of the data being retrieved and written to the output. It&rsquo;s worth noting this value is 8-byte integer.</p><p>At <code>2.</code> there are two variables, at least in the way Binja is displaying the decompilation, with the important point being they are initialised to <code>0xFFFFFFFF</code>, the maximum size available in a 4-byte unsigned integer.</p><p>At <code>3.</code> and <code>4.</code> the calculated expected output length is checked against this upper bound of <code>0xFFFFFFFF</code>, and if it&rsquo;s of a lower value, then the calculated value is fine to proceed with. If it&rsquo;s greater (or actually equal to), the check at <code>4.</code> results in the <code>INTEGER_OVERFLOW</code> error being returned.</p><p>At <code>5.</code> the calculated value is retained in a new variable, and a new variable is initialised that holds the value with the addition of <code>0x38</code>. This adjusted value is compared to the initial value at <code>6.</code>, and this only really makes sense to me as an additional overflow check. Interestingly though, I don&rsquo;t actually think this value could overflow, as <code>0xFFFFFFFF</code> when divided by the <code>0x240</code> size doesn&rsquo;t land close enough to the upper boundary to be overflowed by the <code>+ 0x38</code>. Regardless, it is expected that the adjusted length will be greater than the initial value, and if that is case then at <code>7.</code> our &ldquo;final&rdquo; variable is filled with the adjusted value. <code>8.</code> shows that if there is an overflow, the <code>INTEGER_OVERFLOW</code> status is returned.</p><p>And finally, at <code>9.</code>, there is a key check, that this adjusted value is greater than the <code>OutputBufferLength</code> passed in the I/O call to the driver.</p><p>Here is a comparison with the same function, pre-patch:</p><p><img alt="Pre-patch ScanContainers" loading=lazy src=/CVE-2026-20820/pre-patch_scancontainer.png#center></p><p>So yeah - there are no checks made against the <code>ExpectedOutLen</code> with the addition of the <code>0x38</code> bytes. So we can reasonable assume that we likely have an overflow of some sort by up to <code>0x38</code> bytes past the end of a buffer.</p><p>So what is the <code>0x38</code> bytes?</p><p>Well, it&rsquo;s the context object for the I/O call - specifically, <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_cls_scan_context><code>CLS_SCAN_CONTEXT</code></a>. It is read from the &ldquo;output&rdquo; buffer, as essentially the input to the call, and then that same buffer is used to copy the output into. This might seem confusing given the separation of input/output buffers in <code>DeviceIoControl</code> calls, but it is related to the I/O method used for this specific call. The <code>CClfsRequest::ScanContainers</code> function is reached via the IOCTL <code>0x80076816</code>. Once decoded, this code specifies the buffer method as <code>METHOD_OUT_DIRECT</code>. What this means it that:</p><ul><li>Input buffer = Buffered I/O</li><li>Output buffer = Direct I/O</li></ul><p>When Direct I/O is selected for a buffer management method, the I/O Manager brings the user supplied buffer into physical memory and locks it so it can&rsquo;t be paged out. The I/O Manager the prepares an MDL and assigns a pointer to it to <code>Ipr->MdlAddress</code>. I&rsquo;m not sure if this is actually documented by Microsoft anywhere, but Pavel at least points out in his kernel programming course that the Direct I/O output buffer really can be (and clearly is) used as both the input and the output buffer in certain cases.</p><p>The <code>CLS_SCAN_CONTEXT</code> object has the following definition:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _CLS_SCAN_CONTEXT {
</span></span><span style=display:flex><span>  CLFS_NODE_ID               cidNode;                        <span style=color:#75715e>// 0x0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PLOG_FILE_OBJECT           plfoLog;                        <span style=color:#75715e>// 0x8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ULONG                      cIndex;                         <span style=color:#75715e>// 0x10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ULONG                      cContainers;                    <span style=color:#75715e>// 0x18
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ULONG                      cContainersReturned;            <span style=color:#75715e>// 0x20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  CLFS_SCAN_MODE             eScanMode;                      <span style=color:#75715e>// 0x28
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PCLS_CONTAINER_INFORMATION pinfoContainer;                 <span style=color:#75715e>// 0x30
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} CLS_SCAN_CONTEXT, <span style=color:#f92672>*</span>PCLS_SCAN_CONTEXT, PPCLS_SCAN_CONTEXT;
</span></span></code></pre></div><p>So the root cause of the vulnerability is that, when calculating whether the requested number of container objects <em>fits within</em> the size of the output buffer, the function does not take into consideration that <code>0x38</code> bytes of that output buffer are already taken up by the preceding context object.</p><p>This means that the last <code>0x38</code> bytes of a <code>CLS_CONTAINER_INFORMATION</code> object can be written outside the bounds of the output buffer. If we look at the <code>CLS_CONTAINER_INFORMATION</code> definition:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _CLS_CONTAINER_INFORMATION {
</span></span><span style=display:flex><span>  ULONG                FileAttributes;                       <span style=color:#75715e>// 0x0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ULONGLONG            CreationTime;                         <span style=color:#75715e>// 0x8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ULONGLONG            LastAccessTime;                       <span style=color:#75715e>// 0x10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ULONGLONG            LastWriteTime;                        <span style=color:#75715e>// 0x18
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  LONGLONG             ContainerSize;                        <span style=color:#75715e>// 0x20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ULONG                FileNameActualLength;                 <span style=color:#75715e>// 0x28
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ULONG                FileNameLength;                       <span style=color:#75715e>// 0x2C
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  WCHAR                FileName[CLFS_MAX_CONTAINER_INFO];    <span style=color:#75715e>// 0x30
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  CLFS_CONTAINER_STATE State;                                <span style=color:#75715e>// 0x230
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  CLFS_CONTAINER_ID    PhysicalContainerId;                  <span style=color:#75715e>// 0x234
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  CLFS_CONTAINER_ID    LogicalContainerId;                   <span style=color:#75715e>// 0x238
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} CLS_CONTAINER_INFORMATION, <span style=color:#f92672>*</span>PCLS_CONTAINER_INFORMATION;
</span></span></code></pre></div><p>This ends up being the <code>State</code>, <code>PhysicalContainerId</code>, and the <code>LogicalContainerId</code>, and the final <code>0x28</code> bytes of the <code>FileName</code>.</p><p>These fields are written to a couple of functions later, in <code>CClfsBaseFile::ScanContainerInfo</code>.</p><h2 id=exploit-feasibility>Exploit Feasibility<a hidden class=anchor aria-hidden=true href=#exploit-feasibility>#</a></h2><p>We can quite easily get this to cause a BSOD as an initial PoC that the vulnerability exists. The most straight forward way is to position our user-land buffer at the end of a page of memory, with a guard page adjacent to it. When the driver attempts to write beyond the end of the legitimate buffer, and into the guard page, it will produce a page fault that can&rsquo;t be handled by the kernel, resulting a BSOD.</p><p>This works as expected:</p><p><img alt="CLFS BSOD" loading=lazy src=/CVE-2026-20820/clfs_bsod.png#center></p><p>At this point, however, I got a bit confused by the MSRC advisory. The advisory categorises the CVE as a <em>heap-based</em> buffer overflow - but what we are seeing here isn&rsquo;t really that, it&rsquo;s an overflow of the System PTE pages, into a user-land buffer. Looking around online, and sending an LLM off to do the same thing, didn&rsquo;t yield any examples to me of exploits overflowing virtual memory that is mapped for these MDLs.</p><p>It&rsquo;s possible that I&rsquo;ve misinterpreted the bug <code>¯\_(ツ)_/¯</code>, or that I&rsquo;m overlooking some controllable aspect of the I/O request, that changes where this overflow takes place. Alternatively, the MSRC categorisation might be inaccurate, or there&rsquo;s some technique unknown to me for controlling/influencing where this overflow occurs. Please reach out to me and let me know if this is the case.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://inbits-sec.com/posts/npsvctrig-notes/><span class=title>Next »</span><br><span>Reversing npsvctrig.sys - Named Pipe Service Triggers</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://inbits-sec.com/>Inbits Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>